<p align="center">
  <img src="./docs/assets/logo.png" width="600" alt="goforj/collection logo">
</p>

<p align="center">
    Fluent, Laravel-style Collections for Go - with generics, chainable pipelines, and expressive data transforms.
</p>

<p align="center">
    <a href="https://pkg.go.dev/github.com/goforj/collection"><img src="https://pkg.go.dev/badge/github.com/goforj/collection.svg" alt="Go Reference"></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License: MIT"></a>
    <a href="https://github.com/goforj/collection/actions"><img src="https://github.com/goforj/collection/actions/workflows/test.yml/badge.svg" alt="Go Test"></a>
    <a href="https://golang.org"><img src="https://img.shields.io/badge/go-1.21+-blue?logo=go" alt="Go version"></a>
    <img src="https://img.shields.io/github/v/tag/goforj/collection?label=version&sort=semver" alt="Latest tag">
    <a href="https://codecov.io/gh/goforj/collection" ><img src="https://codecov.io/github/goforj/collection/graph/badge.svg?token=3KFTK96U8C"/></a>
    <a href="https://goreportcard.com/report/github.com/goforj/collection"><img src="https://goreportcard.com/badge/github.com/goforj/collection" alt="Go Report Card"></a>
</p>

<p align="center">
  <code>collection</code> brings an expressive, fluent API to Go.  
  Iterate, filter, transform, sort, reduce, group, and debug your data with zero dependencies.  
  Designed to feel natural to Go developers - and luxurious to everyone else.
</p>

# Features

- üîó **Fluent chaining** - pipeline your operations like Laravel Collections
- üß¨ **Fully generic** (`Collection[T]`) - no reflection, no interface{}
- ‚ö° **Zero dependencies** - pure Go, fast, lightweight
- üßπ **Map / Filter / Reduce** - clean functional transforms
- üîç **First / Last / Find / Contains** helpers
- üìè **Sort, GroupBy, Chunk**, and more
- üß™ **Safe-by-default** - defensive copies where appropriate
- üìú **Built-in JSON helpers** (`ToJSON()`, `ToPrettyJSON()`)
- üß∞ **Developer-friendly debug helpers** (`Dump()`, `Dd()`, `DumpStr()`, `DdStr()`)
- üß± **Works with any Go type**, including structs, pointers, and deeply nested composites

# üì¶ Installation

```bash
go get github.com/goforj/collection
```

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# collection

```go
import "github.com/goforj/collection"
```

## Index

- [func Avg\[T Number\]\(c Collection\[T\]\) float64](<#Avg>)
- [func AvgBy\[T any\]\(c Collection\[T\], fn func\(T\) float64\) float64](<#AvgBy>)
- [func CountBy\[T any, K comparable\]\(c Collection\[T\], fn func\(T\) K\) map\[K\]int](<#CountBy>)
- [func CountByValue\[T comparable\]\(c Collection\[T\]\) map\[T\]int](<#CountByValue>)
- [func Max\[T Number\]\(c Collection\[T\]\) \(T, bool\)](<#Max>)
- [func Median\[T Number\]\(c Collection\[T\]\) \(float64, bool\)](<#Median>)
- [func Min\[T Number\]\(c Collection\[T\]\) \(T, bool\)](<#Min>)
- [func Mode\[T comparable\]\(c Collection\[T\]\) \[\]T](<#Mode>)
- [func Reduce\[T any, R any\]\(c Collection\[T\], initial R, fn func\(R, T\) R\) R](<#Reduce>)
- [func Sum\[T Number\]\(c Collection\[T\]\) T](<#Sum>)
- [func SumBy\[T any, N Number\]\(c Collection\[T\], fn func\(T\) N\) N](<#SumBy>)
- [type Collection](<#Collection>)
  - [func MapTo\[T any, R any\]\(c Collection\[T\], fn func\(T\) R\) Collection\[R\]](<#MapTo>)
  - [func New\[T any\]\(items \[\]T\) Collection\[T\]](<#New>)
  - [func Pluck\[T any, R any\]\(c Collection\[T\], fn func\(T\) R\) Collection\[R\]](<#Pluck>)
  - [func TakeUntil\[T comparable\]\(c Collection\[T\], value T\) Collection\[T\]](<#TakeUntil>)
  - [func Times\[T any\]\(count int, fn func\(int\) T\) Collection\[T\]](<#Times>)
  - [func \(c Collection\[T\]\) After\(pred func\(T\) bool\) Collection\[T\]](<#Collection[T].After>)
  - [func \(c Collection\[T\]\) All\(\) \[\]T](<#Collection[T].All>)
  - [func \(c Collection\[T\]\) Any\(fn func\(T\) bool\) bool](<#Collection[T].Any>)
  - [func \(c Collection\[T\]\) Append\(values ...T\) Collection\[T\]](<#Collection[T].Append>)
  - [func \(c Collection\[T\]\) Before\(pred func\(T\) bool\) Collection\[T\]](<#Collection[T].Before>)
  - [func \(c Collection\[T\]\) Chunk\(size int\) \[\]\[\]T](<#Collection[T].Chunk>)
  - [func \(c Collection\[T\]\) Concat\(values \[\]T\) Collection\[T\]](<#Collection[T].Concat>)
  - [func \(c Collection\[T\]\) Contains\(pred func\(T\) bool\) bool](<#Collection[T].Contains>)
  - [func \(c Collection\[T\]\) Count\(\) int](<#Collection[T].Count>)
  - [func \(c Collection\[T\]\) Dd\(\)](<#Collection[T].Dd>)
  - [func \(c Collection\[T\]\) DdStr\(\) string](<#Collection[T].DdStr>)
  - [func \(c Collection\[T\]\) Dump\(\) Collection\[T\]](<#Collection[T].Dump>)
  - [func \(c Collection\[T\]\) DumpStr\(\) string](<#Collection[T].DumpStr>)
  - [func \(c Collection\[T\]\) Each\(fn func\(T\)\) Collection\[T\]](<#Collection[T].Each>)
  - [func \(c Collection\[T\]\) Filter\(fn func\(T\) bool\) Collection\[T\]](<#Collection[T].Filter>)
  - [func \(c Collection\[T\]\) FindWhere\(fn func\(T\) bool\) \(T, bool\)](<#Collection[T].FindWhere>)
  - [func \(c Collection\[T\]\) First\(\) \(value T, ok bool\)](<#Collection[T].First>)
  - [func \(c Collection\[T\]\) FirstWhere\(fn func\(T\) bool\) \(value T, ok bool\)](<#Collection[T].FirstWhere>)
  - [func \(c Collection\[T\]\) IsEmpty\(\) bool](<#Collection[T].IsEmpty>)
  - [func \(c Collection\[T\]\) Items\(\) \[\]T](<#Collection[T].Items>)
  - [func \(c Collection\[T\]\) Last\(\) \(value T, ok bool\)](<#Collection[T].Last>)
  - [func \(c Collection\[T\]\) LastWhere\(fn func\(T, int\) bool\) \(value T, ok bool\)](<#Collection[T].LastWhere>)
  - [func \(c Collection\[T\]\) Map\(fn func\(T\) T\) Collection\[T\]](<#Collection[T].Map>)
  - [func \(c Collection\[T\]\) Merge\(other any\) Collection\[T\]](<#Collection[T].Merge>)
  - [func \(c Collection\[T\]\) Multiply\(n int\) Collection\[T\]](<#Collection[T].Multiply>)
  - [func \(c Collection\[T\]\) Pipe\(fn func\(Collection\[T\]\) any\) any](<#Collection[T].Pipe>)
  - [func \(c Collection\[T\]\) Pop\(\) \(T, Collection\[T\]\)](<#Collection[T].Pop>)
  - [func \(c Collection\[T\]\) PopN\(n int\) \(Collection\[T\], Collection\[T\]\)](<#Collection[T].PopN>)
  - [func \(c Collection\[T\]\) Prepend\(values ...T\) Collection\[T\]](<#Collection[T].Prepend>)
  - [func \(c Collection\[T\]\) Push\(values ...T\) Collection\[T\]](<#Collection[T].Push>)
  - [func \(c Collection\[T\]\) Sort\(less func\(a, b T\) bool\) Collection\[T\]](<#Collection[T].Sort>)
  - [func \(c Collection\[T\]\) Take\(n int\) Collection\[T\]](<#Collection[T].Take>)
  - [func \(c Collection\[T\]\) TakeUntilFn\(pred func\(T\) bool\) Collection\[T\]](<#Collection[T].TakeUntilFn>)
  - [func \(c Collection\[T\]\) Tap\(fn func\(Collection\[T\]\)\) Collection\[T\]](<#Collection[T].Tap>)
  - [func \(c Collection\[T\]\) ToJSON\(\) \(string, error\)](<#Collection[T].ToJSON>)
  - [func \(c Collection\[T\]\) ToPrettyJSON\(\) \(string, error\)](<#Collection[T].ToPrettyJSON>)
  - [func \(c Collection\[T\]\) Transform\(fn func\(T\) T\)](<#Collection[T].Transform>)
  - [func \(c Collection\[T\]\) Unique\(eq func\(a, b T\) bool\) Collection\[T\]](<#Collection[T].Unique>)
- [type Number](<#Number>)


<a name="Avg"></a>
## func [Avg](<https://github.com/goforj/collection/blob/main/avg.go#L5>)

```go
func Avg[T Number](c Collection[T]) float64
```

Avg returns the average as float64. Even integer averages may be fractional.

<a name="AvgBy"></a>
## func [AvgBy](<https://github.com/goforj/collection/blob/main/collection.go#L71>)

```go
func AvgBy[T any](c Collection[T], fn func(T) float64) float64
```

AvgBy calculates the average of values extracted by fn from the collection items.

Example:

```
avgAge := AvgBy(users, func(u User) float64 { return float64(u.Age) })
```

<a name="CountBy"></a>
## func [CountBy](<https://github.com/goforj/collection/blob/main/count_by.go#L8>)

```go
func CountBy[T any, K comparable](c Collection[T], fn func(T) K) map[K]int
```

CountBy returns a map of keys extracted by fn to their occurrence counts. K must be comparable. Example:

```
counts := CountBy(users, func(u User) string { return u.Role })
// counts == map[string]int{"admin": 3, "user": 5}
```

<a name="CountByValue"></a>
## func [CountByValue](<https://github.com/goforj/collection/blob/main/count_by.go#L25>)

```go
func CountByValue[T comparable](c Collection[T]) map[T]int
```

CountByValue returns a map of item values to their occurrence counts. T must be comparable. Example:

```
counts := CountByValue(collection.New([]string{"a", "b", "a"}))
// counts == map[string]int{"a": 2, "b": 1}
```

<a name="Max"></a>
## func [Max](<https://github.com/goforj/collection/blob/main/max.go#L5>)

```go
func Max[T Number](c Collection[T]) (T, bool)
```

Max returns the largest numeric item. Second return is false if empty.

<a name="Median"></a>
## func [Median](<https://github.com/goforj/collection/blob/main/median.go#L11>)

```go
func Median[T Number](c Collection[T]) (float64, bool)
```

Median returns the median as float64. Fractional medians handled correctly. False if empty. Example:

```
c := collection.New([]int{3,1,2})
median, ok := Median(c) ‚Üí 2, true
```

<a name="Min"></a>
## func [Min](<https://github.com/goforj/collection/blob/main/min.go#L8>)

```go
func Min[T Number](c Collection[T]) (T, bool)
```

Min returns the smallest numeric item. Second return is false if empty. Example:

```
c := collection.New([]int{3,1,2})
min, ok := Min(c) ‚Üí 1, true
```

<a name="Mode"></a>
## func [Mode](<https://github.com/goforj/collection/blob/main/mode.go#L5>)

```go
func Mode[T comparable](c Collection[T]) []T
```

Mode returns the most frequent value\(s\). If tie, returns all values with max freq in first\-seen order.

<a name="Reduce"></a>
## func [Reduce](<https://github.com/goforj/collection/blob/main/reduce.go#L10>)

```go
func Reduce[T any, R any](c Collection[T], initial R, fn func(R, T) R) R
```

Reduce reduces a collection of T into a single value of type R.

Example:

```
sum := Reduce(nums, 0, func(acc, n int) int { return acc + n })
```

// sum is the total of all numbers in nums concatenated := Reduce\(strings, "", func\(acc, s string\) string \{ return acc \+ s \}\) // concatenated is all strings in strings joined together

<a name="Sum"></a>
## func [Sum](<https://github.com/goforj/collection/blob/main/sum.go#L4>)

```go
func Sum[T Number](c Collection[T]) T
```

Sum returns the sum of all numeric items.

<a name="SumBy"></a>
## func [SumBy](<https://github.com/goforj/collection/blob/main/collection.go#L92>)

```go
func SumBy[T any, N Number](c Collection[T], fn func(T) N) N
```

SumBy returns the sum of a numeric projection from each item.

Example \(structs\):

```
type Row struct{ Foo int }
rows := New([]Row{{10}, {20}})
total := SumBy(rows, func(r Row) int { return r.Foo }) // 30
```

<a name="Collection"></a>
## type [Collection](<https://github.com/goforj/collection/blob/main/collection.go#L4-L6>)

Collection is a strongly\-typed, fluent wrapper around a slice of T.

```go
type Collection[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="MapTo"></a>
### func [MapTo](<https://github.com/goforj/collection/blob/main/pluck.go#L9>)

```go
func MapTo[T any, R any](c Collection[T], fn func(T) R) Collection[R]
```

MapTo maps a Collection\[T\] to a Collection\[R\] using fn\(T\) R.

This cannot be a method because methods can't introduce a new type parameter R. Example:

```
squared := numbers.MapTo(func(n int) int { return n * n })
// squared is a Collection[int] of squared numbers
```

<a name="New"></a>
### func [New](<https://github.com/goforj/collection/blob/main/collection.go#L17>)

```go
func New[T any](items []T) Collection[T]
```

New wraps a slice in a Collection. A shallow copy is made so that further operations don't mutate the original slice.

<a name="Pluck"></a>
### func [Pluck](<https://github.com/goforj/collection/blob/main/pluck.go#L22>)

```go
func Pluck[T any, R any](c Collection[T], fn func(T) R) Collection[R]
```

Pluck is an alias for MapTo with a more semantic name when projecting fields. Example:

```
names := users.Pluck(func(u User) string { return u.Name })
// names is a Collection[string] of user names
```

<a name="TakeUntil"></a>
### func [TakeUntil](<https://github.com/goforj/collection/blob/main/take_until.go#L27>)

```go
func TakeUntil[T comparable](c Collection[T], value T) Collection[T]
```

TakeUntil returns items until the first element equals \`value\`. The matching item is NOT included.

Uses == comparison, so T must be comparable.

<a name="Times"></a>
### func [Times](<https://github.com/goforj/collection/blob/main/times.go#L9>)

```go
func Times[T any](count int, fn func(int) T) Collection[T]
```

Times creates a new collection by running fn\(n\) for i from 1..count. This mirrors Laravel's Collection::times\(\), which is 1\-indexed.

Example:

```
c := collection.Times(5, func(i int) int { return i * 2 })
// [2,4,6,8,10]
```

<a name="Collection[T].After"></a>
### func \(Collection\[T\]\) [After](<https://github.com/goforj/collection/blob/main/after.go#L10>)

```go
func (c Collection[T]) After(pred func(T) bool) Collection[T]
```

After returns all items after the first element for which pred returns true. If no element matches, an empty collection is returned.

Example:

```
c := collection.New([]int{1,2,3,4,5})
c.After(func(v int) bool { return v == 3 })
// [4,5]
```

<a name="Collection[T].All"></a>
### func \(Collection\[T\]\) [All](<https://github.com/goforj/collection/blob/main/collection.go#L41>)

```go
func (c Collection[T]) All() []T
```

All returns the underlying slice of items.

<a name="Collection[T].Any"></a>
### func \(Collection\[T\]\) [Any](<https://github.com/goforj/collection/blob/main/any.go#L8>)

```go
func (c Collection[T]) Any(fn func(T) bool) bool
```

Any returns true if at least one item satisfies fn. Example: c := collection.New\(\[\]int\{1, 2, 3, 4\}\) hasEven := c.Any\(func\(v int\) bool \{ return v%2 == 0 \}\) // true // hasEven is true

<a name="Collection[T].Append"></a>
### func \(Collection\[T\]\) [Append](<https://github.com/goforj/collection/blob/main/append.go#L8>)

```go
func (c Collection[T]) Append(values ...T) Collection[T]
```

Append returns a new collection with the given values appended. Example:

```
c := collection.New([]int{1, 2})
newC := c.Append(3, 4) // Collection with items [1, 2, 3, 4]
// newC.Items() == []int{1, 2, 3, 4}
```

<a name="Collection[T].Before"></a>
### func \(Collection\[T\]\) [Before](<https://github.com/goforj/collection/blob/main/collection.go#L53>)

```go
func (c Collection[T]) Before(pred func(T) bool) Collection[T]
```

Before returns all items before the first element for which pred returns true. If no element matches, the entire collection is returned.

<a name="Collection[T].Chunk"></a>
### func \(Collection\[T\]\) [Chunk](<https://github.com/goforj/collection/blob/main/chunk.go#L10>)

```go
func (c Collection[T]) Chunk(size int) [][]T
```

Chunk splits the collection into chunks of the given size. The final chunk may be smaller if len\(items\) is not divisible by size.

If size \<= 0, nil is returned. Example:

```
c := collection.New([]int{1,2,3,4,5})
chunks := c.Chunk(2) ‚Üí [[1,2],[3,4],[5]]
```

<a name="Collection[T].Concat"></a>
### func \(Collection\[T\]\) [Concat](<https://github.com/goforj/collection/blob/main/concat.go#L26>)

```go
func (c Collection[T]) Concat(values []T) Collection[T]
```

Concat appends the values from the given slice onto the end of the collection, returning a new collection. The original collection is never modified.

This mirrors Laravel's concat\(\): the appended values are numerically reindexed in the resulting collection, regardless of their original keys or positions.

Example:

```
c := collection.New([]string{"John Doe"})

concatenated := c.
    Concat([]string{"Jane Doe"}).
    Concat([]string{"Johnny Doe"})

// concatenated.Items()
// ["John Doe", "Jane Doe", "Johnny Doe"]
```

Notes:

- Concat never mutates the original collection.
- Keys/indices from the appended slice are ignored; values are simply appended.
- To concatenate another Collection\[T\], use: c.Concat\(other.Items\(\)\)

<a name="Collection[T].Contains"></a>
### func \(Collection\[T\]\) [Contains](<https://github.com/goforj/collection/blob/main/contains.go#L9>)

```go
func (c Collection[T]) Contains(pred func(T) bool) bool
```

Contains returns true if any item satisfies the predicate. Example:

```
c := collection.New([]int{1, 2, 3, 4})
hasEven := c.Contains(func(v int) bool { return v%2 == 0 }) // true
```

// hasEven is true

<a name="Collection[T].Count"></a>
### func \(Collection\[T\]\) [Count](<https://github.com/goforj/collection/blob/main/count.go#L7>)

```go
func (c Collection[T]) Count() int
```

Count returns the total number of items in the collection. Example:

```
c := collection.New([]int{1, 2, 3, 4})
count := c.Count() // 4
```

<a name="Collection[T].Dd"></a>
### func \(Collection\[T\]\) [Dd](<https://github.com/goforj/collection/blob/main/dump.go#L25>)

```go
func (c Collection[T]) Dd()
```

Dd pretty\-prints the collection contents using goforj/godump and then exits the program \(just like Laravel's dd\(\)\).

Example:

```
users.
  Filter(func(u User) bool { return u.Age >= 35 }).
  Dd()
```

<a name="Collection[T].DdStr"></a>
### func \(Collection\[T\]\) [DdStr](<https://github.com/goforj/collection/blob/main/dump.go#L50>)

```go
func (c Collection[T]) DdStr() string
```

DdStr pretty\-prints the collection items using godump.DumpStr and returns the string, AND then exits ‚Äî just like Laravel's dd\(\), except here the exit is performed via godump.exitFunc so tests can override it.

Example:

```
output := users.Filter(active).DdStr()
// program exits after printing
```

<a name="Collection[T].Dump"></a>
### func \(Collection\[T\]\) [Dump](<https://github.com/goforj/collection/blob/main/dump.go#L13>)

```go
func (c Collection[T]) Dump() Collection[T]
```

Dump pretty\-prints the collection contents using goforj/godump and returns the collection so it can be used mid\-chain.

Example:

```
users.
  Filter(func(u User) bool { return u.Age >= 35 }).
  Dump().
  Sort(func(a, b User) bool { return a.Age < b.Age })
```

<a name="Collection[T].DumpStr"></a>
### func \(Collection\[T\]\) [DumpStr](<https://github.com/goforj/collection/blob/main/dump.go#L37>)

```go
func (c Collection[T]) DumpStr() string
```

DumpStr pretty\-prints the collection items using godump.DumpStr and returns the string. Unlike Dump\(\), this does not print to stdout and does not interrupt a chain.

Example:

```
s := users.Filter(active).DumpStr()
```

<a name="Collection[T].Each"></a>
### func \(Collection\[T\]\) [Each](<https://github.com/goforj/collection/blob/main/each.go#L5>)

```go
func (c Collection[T]) Each(fn func(T)) Collection[T]
```

Each runs fn for every item in the collection and returns the same collection, so it can be used in chains for side effects \(logging, debugging, etc.\).

<a name="Collection[T].Filter"></a>
### func \(Collection\[T\]\) [Filter](<https://github.com/goforj/collection/blob/main/filter.go#L12>)

```go
func (c Collection[T]) Filter(fn func(T) bool) Collection[T]
```

Filter returns a new collection containing only values for which fn returns true.

This keeps T the same, so it can be a method. Example usage:

```
c := collection.New([]int{1, 2, 3, 4, 5})
filtered := c.Filter(func(v int) bool { return v%2 == 0 }) // keeps even numbers
```

// result: \[2, 4\]

<a name="Collection[T].FindWhere"></a>
### func \(Collection\[T\]\) [FindWhere](<https://github.com/goforj/collection/blob/main/find_where.go#L25>)

```go
func (c Collection[T]) FindWhere(fn func(T) bool) (T, bool)
```

FindWhere returns the first item in the collection for which the provided predicate function returns true. This method is an alias for FirstWhere\(fn\) and is provided for ergonomic parity with functional libraries and languages such as JavaScript, Rust, C\#, and Python.

FindWhere improves discoverability for developers who naturally search for a "find" helper when retrieving an element that matches a condition.

Examples:

```
nums := New([]int{1, 2, 3, 4, 5})

v, ok := nums.FindWhere(func(n int) bool {
    return n == 3
})
// v = 3, ok = true

v, ok = nums.FindWhere(func(n int) bool {
    return n > 10
})
// v = 0, ok = false
```

<a name="Collection[T].First"></a>
### func \(Collection\[T\]\) [First](<https://github.com/goforj/collection/blob/main/first.go#L18>)

```go
func (c Collection[T]) First() (value T, ok bool)
```

First returns the first element in the collection. If the collection is empty, ok will be false.

Example:

```
c := New([]int{1, 2, 3, 4})
v, ok := c.First()
// v == 1, ok == true
```

Example \(empty\):

```
c := New([]int{})
v, ok := c.First()
// v == 0, ok == false
```

<a name="Collection[T].FirstWhere"></a>
### func \(Collection\[T\]\) [FirstWhere](<https://github.com/goforj/collection/blob/main/first_where.go#L23>)

```go
func (c Collection[T]) FirstWhere(fn func(T) bool) (value T, ok bool)
```

FirstWhere returns the first item in the collection for which the provided predicate function returns true. If no items match, ok=false is returned along with the zero value of T.

This method is equivalent to Laravel's collection\-\>first\(fn\) and mirrors the behavior found in functional collections in other languages.

Examples:

```
nums := New([]int{1, 2, 3, 4, 5})
v, ok := nums.FirstWhere(func(n int) bool {
    return n%2 == 0
})
// v = 2, ok = true

v, ok = nums.FirstWhere(func(n int) bool {
    return n > 10
})
// v = 0, ok = false
```

<a name="Collection[T].IsEmpty"></a>
### func \(Collection\[T\]\) [IsEmpty](<https://github.com/goforj/collection/blob/main/collection.go#L32>)

```go
func (c Collection[T]) IsEmpty() bool
```

IsEmpty returns true if the collection has no items.

<a name="Collection[T].Items"></a>
### func \(Collection\[T\]\) [Items](<https://github.com/goforj/collection/blob/main/collection.go#L25>)

```go
func (c Collection[T]) Items() []T
```

Items returns a copy of the underlying slice. This avoids callers mutating internal state accidentally.

<a name="Collection[T].Last"></a>
### func \(Collection\[T\]\) [Last](<https://github.com/goforj/collection/blob/main/last.go#L18>)

```go
func (c Collection[T]) Last() (value T, ok bool)
```

Last returns the last element in the collection. If the collection is empty, ok will be false.

Example:

```
c := collection.New([]int{1, 2, 3, 4})
v, ok := c.Last()
// v == 4, ok == true
```

Example \(empty\):

```
c := collection.New([]int{})
v, ok := c.Last()
// v == 0, ok == false
```

<a name="Collection[T].LastWhere"></a>
### func \(Collection\[T\]\) [LastWhere](<https://github.com/goforj/collection/blob/main/last_where.go#L27>)

```go
func (c Collection[T]) LastWhere(fn func(T, int) bool) (value T, ok bool)
```

LastWhere returns the last element in the collection that satisfies the predicate fn. If fn is nil, LastWhere returns the final element in the underlying slice. If the collection is empty or no element matches, ok will be false.

Example: LastWhere with predicate

```
c := collection.New([]int{1, 2, 3, 4})
v, ok := c.LastWhere(func(v int, i int) bool {
    return v < 3
})
// v == 2, ok == true
```

Example: LastWhere without predicate

```
c := collection.New([]int{1, 2, 3, 4})
v, ok := c.LastWhere(nil)
// v == 4, ok == true
```

Example: Empty collection

```
c := collection.New([]int{})
v, ok := c.LastWhere(nil)
// v == 0, ok == false
```

<a name="Collection[T].Map"></a>
### func \(Collection\[T\]\) [Map](<https://github.com/goforj/collection/blob/main/map.go#L11>)

```go
func (c Collection[T]) Map(fn func(T) T) Collection[T]
```

Map applies a same\-type transformation and returns a new collection.

Use this when you're transforming T \-\> T \(e.g., enrichment, normalization\). Example usage:

```
c := collection.New([]int{1, 2, 3})
	mapped := c.Map(func(v int) int { return v * 10 }) // [10, 20, 30]
 // expected := []int{10, 20, 30}
```

<a name="Collection[T].Merge"></a>
### func \(Collection\[T\]\) [Merge](<https://github.com/goforj/collection/blob/main/merge.go#L26>)

```go
func (c Collection[T]) Merge(other any) Collection[T]
```

Merge merges the given data into the current collection using Laravel\-style semantics.

Behavior depends on the type of \`other\`:

- \[\]T \(numeric merges\) Values are appended to the end of the collection.

- Collection\[T\] Values are appended, same as merging a slice.

- map\[string\]T \(associative merges\) Keys that already exist overwrite the original values; new keys are added.

Unsupported merge types are ignored. This method never panics and always returns a new Collection.

<a name="Collection[T].Multiply"></a>
### func \(Collection\[T\]\) [Multiply](<https://github.com/goforj/collection/blob/main/multiply.go#L14>)

```go
func (c Collection[T]) Multiply(n int) Collection[T]
```

Multiply creates \`n\` copies of all items in the collection and returns a new collection.

Example:

```
users := New([]User{{Name: "A"}, {Name: "B"}})
out := users.Multiply(3)
```

Resulting items:

```
[A, B, A, B, A, B]
```

If n \<= 0, the method returns an empty collection.

<a name="Collection[T].Pipe"></a>
### func \(Collection\[T\]\) [Pipe](<https://github.com/goforj/collection/blob/main/pipe.go#L18>)

```go
func (c Collection[T]) Pipe(fn func(Collection[T]) any) any
```

Pipe passes the entire collection into the given function and returns the function's result.

This is useful for inline transformations, aggregations, or "exiting" a chain with a non\-collection value.

Example:

```
c := New([]int{1, 2, 3})
sum := c.Pipe(func(col Collection[int]) any {
    return col.Sum()
})

// sum == 6
```

<a name="Collection[T].Pop"></a>
### func \(Collection\[T\]\) [Pop](<https://github.com/goforj/collection/blob/main/pop.go#L8>)

```go
func (c Collection[T]) Pop() (T, Collection[T])
```

Pop returns the last item and a new collection with that item removed. The original collection remains unchanged.

If the collection is empty, the zero value of T is returned along with an empty collection.

<a name="Collection[T].PopN"></a>
### func \(Collection\[T\]\) [PopN](<https://github.com/goforj/collection/blob/main/pop.go#L24>)

```go
func (c Collection[T]) PopN(n int) (Collection[T], Collection[T])
```

PopN removes and returns the last n items as a new collection, and returns a second collection containing the remaining items.

<a name="Collection[T].Prepend"></a>
### func \(Collection\[T\]\) [Prepend](<https://github.com/goforj/collection/blob/main/prepend.go#L8>)

```go
func (c Collection[T]) Prepend(values ...T) Collection[T]
```

Prepend returns a new collection with the given values prepended. Example:

```
c := collection.New([]int{3, 4})
newC := c.Prepend(1, 2) // Collection with items [1, 2, 3, 4]
// newC.Items() == []int{1, 2, 3, 4}
```

<a name="Collection[T].Push"></a>
### func \(Collection\[T\]\) [Push](<https://github.com/goforj/collection/blob/main/append.go#L20>)

```go
func (c Collection[T]) Push(values ...T) Collection[T]
```

Push returns a new collection with the given values appended. Example:

```
c := collection.New([]int{1, 2})
newC := c.Push(3, 4) // Collection with items [1, 2, 3, 4]
// newC.Items() == []int{1, 2, 3, 4}
```

<a name="Collection[T].Sort"></a>
### func \(Collection\[T\]\) [Sort](<https://github.com/goforj/collection/blob/main/sort.go#L12>)

```go
func (c Collection[T]) Sort(less func(a, b T) bool) Collection[T]
```

Sort returns a new collection sorted using the given comparison function.

less should return true if a should come before b.

Example:

```
sorted := users.Sort(func(a, b User) bool { return a.Age < b.Age })
// sorted by Age ascending
```

<a name="Collection[T].Take"></a>
### func \(Collection\[T\]\) [Take](<https://github.com/goforj/collection/blob/main/take.go#L12>)

```go
func (c Collection[T]) Take(n int) Collection[T]
```

Take returns a new collection containing the first \`n\` items when n \> 0, or the last \`|n|\` items when n \< 0. If n exceeds the collection length, the entire slice \(or nothing\) is returned.

Mirrors Laravel's take\(\) semantics.

Examples:

```
New([]int{0,1,2,3,4,5}).Take(3)  ‚Üí [0,1,2]
New([]int{0,1,2,3,4,5}).Take(-2) ‚Üí [4,5]
```

<a name="Collection[T].TakeUntilFn"></a>
### func \(Collection\[T\]\) [TakeUntilFn](<https://github.com/goforj/collection/blob/main/take_until.go#L10>)

```go
func (c Collection[T]) TakeUntilFn(pred func(T) bool) Collection[T]
```

TakeUntilFn returns items until the predicate function returns true. The matching item is NOT included. Example:

```
c := collection.New([]int{1, 2, 3, 4})
out := c.TakeUntilFn(func(v int) bool { return v >= 3 }) // [1, 2]
```

// result is \[1, 2\]

<a name="Collection[T].Tap"></a>
### func \(Collection\[T\]\) [Tap](<https://github.com/goforj/collection/blob/main/tap.go#L14>)

```go
func (c Collection[T]) Tap(fn func(Collection[T])) Collection[T]
```

Tap passes the collection to fn for side effects \(logging, inspection, debugging\) without modifying the collection. The collection is returned so it can continue chaining, matching Laravel's behavior.

Example:

```
c := New([]int{3,1,2}).Sort(func(a,b int) bool { return a < b }).Tap(func(col Collection[int]) {
    fmt.Println("After sorting:", col.Items())
})

// c is still the sorted collection.
```

<a name="Collection[T].ToJSON"></a>
### func \(Collection\[T\]\) [ToJSON](<https://github.com/goforj/collection/blob/main/to_json.go#L38>)

```go
func (c Collection[T]) ToJSON() (string, error)
```

ToJSON converts the collection's items into a compact JSON string.

If marshalling succeeds, a JSON\-encoded string and a nil error are returned. If marshalling fails, the method unwraps any json.Marshal wrapping so that user\-defined MarshalJSON errors surface directly.

This method never panics.

Example:

```
c := collection.New([]int{1, 2, 3})
out, err := c.ToJSON()
// out: "[1,2,3]"
// err: nil
```

Example \(error\):

```
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the JSON\-encoded representation of the collection
- error : nil on success, or the unwrapped marshalling error

<a name="Collection[T].ToPrettyJSON"></a>
### func \(Collection\[T\]\) [ToPrettyJSON](<https://github.com/goforj/collection/blob/main/to_json.go#L82>)

```go
func (c Collection[T]) ToPrettyJSON() (string, error)
```

ToPrettyJSON converts the collection's items into an indented, human\-readable JSON string.

If marshalling succeeds, a formatted JSON string and nil error are returned. If marshalling fails, the underlying error is unwrapped so that user\-defined MarshalJSON failures surface directly \(e.g., "marshal failure"\) rather than the json.MarshalIndent wrapper.

This method never panics.

Example:

```
c := collection.New([]string{"a", "b"})
out, err := c.ToPrettyJSON()
// out:
// [
//   "a",
//   "b"
// ]
// err: nil
```

Example \(error\):

```
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToPrettyJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the pretty\-printed JSON representation
- error : nil on success, or the unwrapped marshalling error

<a name="Collection[T].Transform"></a>
### func \(Collection\[T\]\) [Transform](<https://github.com/goforj/collection/blob/main/transform.go#L10>)

```go
func (c Collection[T]) Transform(fn func(T) T)
```

Transform applies fn to every item \*in place\* and replaces the values with the returned values. This matches Laravel's transform\(\), which mutates the collection instead of returning a new one. Example:

```
c := collection.New([]int{1,2,3})
c.Transform(func(v int) int { return v * 2 })
// c is now [2,4,6]
```

<a name="Collection[T].Unique"></a>
### func \(Collection\[T\]\) [Unique](<https://github.com/goforj/collection/blob/main/unique.go#L13>)

```go
func (c Collection[T]) Unique(eq func(a, b T) bool) Collection[T]
```

Unique returns a collection with duplicate items \(according to eq\) removed, preserving the first occurrence of each unique value.

eq should return true if the two values are considered equal. Example usage:

```
c := collection.New([]int{1, 2, 2, 3, 4, 4, 5})
unique := c.Unique(func(a, b int) bool { return a == b })

// result: [1, 2, 3, 4, 5]
```

<a name="Number"></a>
## type [Number](<https://github.com/goforj/collection/blob/main/collection.go#L9-L13>)

Number is a constraint that permits any numeric type.

```go
type Number interface {
    // contains filtered or unexported methods
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->