<p align="center">
  <img src="./docs/assets/logo.png" width="600" alt="goforj/collection logo">
</p>

<p align="center">
    Fluent, Laravel-style Collections for Go - with generics, chainable pipelines, and expressive data transforms.
</p>

<p align="center">
    <a href="https://pkg.go.dev/github.com/goforj/collection"><img src="https://pkg.go.dev/badge/github.com/goforj/collection.svg" alt="Go Reference"></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License: MIT"></a>
    <a href="https://github.com/goforj/collection/actions"><img src="https://github.com/goforj/collection/actions/workflows/test.yml/badge.svg" alt="Go Test"></a>
    <a href="https://golang.org"><img src="https://img.shields.io/badge/go-1.21+-blue?logo=go" alt="Go version"></a>
    <img src="https://img.shields.io/github/v/tag/goforj/collection?label=version&sort=semver" alt="Latest tag">
    <a href="https://codecov.io/gh/goforj/collection" ><img src="https://codecov.io/github/goforj/collection/graph/badge.svg?token=3KFTK96U8C"/></a>
    <a href="https://goreportcard.com/report/github.com/goforj/collection"><img src="https://goreportcard.com/badge/github.com/goforj/collection" alt="Go Report Card"></a>
</p>

<p align="center">
  <code>collection</code> brings an expressive, fluent API to Go.  
  Iterate, filter, transform, sort, reduce, group, and debug your data with zero dependencies.  
  Designed to feel natural to Go developers - and luxurious to everyone else.
</p>

# Features

- üîó **Fluent chaining** - pipeline your operations like Laravel Collections
- üß¨ **Fully generic** (`Collection[T]`) - no reflection, no `interface{}`
- ‚ö° **Zero dependencies** - pure Go, fast, lightweight
- üßµ **Minimal allocations** - avoids unnecessary copies; most operations reuse the underlying slice
- üßπ **Map / Filter / Reduce** - clean functional transforms
- üîç **First / Last / Find / Contains** helpers
- üìè **Sort, GroupBy, Chunk**, and more
- üß™ **Safe-by-default** - defensive copies where appropriate
- üìú **Built-in JSON helpers** (`ToJSON()`, `ToPrettyJSON()`)
- üß∞ **Developer-friendly debug helpers** (`Dump()`, `Dd()`, `DumpStr()`, `DdStr()`)
- üß± **Works with any Go type**, including structs, pointers, and deeply nested composites

# üì¶ Installation

```bash
go get github.com/goforj/collection
```

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# collection

```go
import "github.com/goforj/collection"
```

## Index

| Name | Parent | Kind | Source |
|------|--------|-------|--------|
| [CountBy](<#CountBy>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/count_by.go#L56" target="_blank">Source</a> |
| [CountByValue](<#CountByValue>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/count_by.go#L70" target="_blank">Source</a> |
| [Dump](<#Dump>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/dump.go#L95" target="_blank">Source</a> |
| [type Collection](<#Collection>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L4-L6" target="_blank">Source</a> |
| [MapTo](<#MapTo>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/pluck.go#L9" target="_blank">Source</a> |
| [New](<#New>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/collection.go#L17" target="_blank">Source</a> |
| [Pluck](<#Pluck>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/pluck.go#L22" target="_blank">Source</a> |
| [TakeUntil](<#TakeUntil>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/take_until.go#L27" target="_blank">Source</a> |
| [Times](<#Times>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/times.go#L9" target="_blank">Source</a> |
| [After](<#Collection[T].After>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/after.go#L13" target="_blank">Source</a> |
| [Any](<#Collection[T].Any>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/any.go#L9" target="_blank">Source</a> |
| [Append](<#Collection[T].Append>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/append.go#L50" target="_blank">Source</a> |
| [Before](<#Collection[T].Before>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/before.go#L5" target="_blank">Source</a> |
| [Chunk](<#Collection[T].Chunk>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/chunk.go#L66" target="_blank">Source</a> |
| [Concat](<#Collection[T].Concat>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/concat.go#L22" target="_blank">Source</a> |
| [Contains](<#Collection[T].Contains>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/contains.go#L40" target="_blank">Source</a> |
| [Count](<#Collection[T].Count>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/count.go#L8" target="_blank">Source</a> |
| [Dd](<#Collection[T].Dd>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L54" target="_blank">Source</a> |
| [Dump](<#Collection[T].Dump>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L34" target="_blank">Source</a> |
| [DumpStr](<#Collection[T].DumpStr>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L71" target="_blank">Source</a> |
| [Each](<#Collection[T].Each>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/each.go#L58" target="_blank">Source</a> |
| [Filter](<#Collection[T].Filter>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/filter.go#L59" target="_blank">Source</a> |
| [FindWhere](<#Collection[T].FindWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/find_where.go#L25" target="_blank">Source</a> |
| [First](<#Collection[T].First>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/first.go#L51" target="_blank">Source</a> |
| [FirstWhere](<#Collection[T].FirstWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/first_where.go#L23" target="_blank">Source</a> |
| [IsEmpty](<#Collection[T].IsEmpty>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/is_empty.go#L43" target="_blank">Source</a> |
| [Items](<#Collection[T].Items>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/collection.go#L35" target="_blank">Source</a> |
| [Last](<#Collection[T].Last>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/last.go#L53" target="_blank">Source</a> |
| [LastWhere](<#Collection[T].LastWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/last_where.go#L81" target="_blank">Source</a> |
| [Map](<#Collection[T].Map>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/map.go#L65" target="_blank">Source</a> |
| [Merge](<#Collection[T].Merge>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/merge.go#L20" target="_blank">Source</a> |
| [Multiply](<#Collection[T].Multiply>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/multiply.go#L12" target="_blank">Source</a> |
| [Pipe](<#Collection[T].Pipe>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pipe.go#L18" target="_blank">Source</a> |
| [Pop](<#Collection[T].Pop>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pop.go#L8" target="_blank">Source</a> |
| [PopN](<#Collection[T].PopN>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pop.go#L24" target="_blank">Source</a> |
| [Prepend](<#Collection[T].Prepend>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/prepend.go#L8" target="_blank">Source</a> |
| [Push](<#Collection[T].Push>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/append.go#L86" target="_blank">Source</a> |
| [Reduce](<#Collection[T].Reduce>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/reduce.go#L46" target="_blank">Source</a> |
| [Sort](<#Collection[T].Sort>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/sort.go#L12" target="_blank">Source</a> |
| [Take](<#Collection[T].Take>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/take.go#L12" target="_blank">Source</a> |
| [TakeUntilFn](<#Collection[T].TakeUntilFn>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/take_until.go#L10" target="_blank">Source</a> |
| [Tap](<#Collection[T].Tap>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/tap.go#L21" target="_blank">Source</a> |
| [ToJSON](<#Collection[T].ToJSON>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/to_json.go#L38" target="_blank">Source</a> |
| [ToPrettyJSON](<#Collection[T].ToPrettyJSON>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/to_json.go#L82" target="_blank">Source</a> |
| [Transform](<#Collection[T].Transform>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/transform.go#L10" target="_blank">Source</a> |
| [Unique](<#Collection[T].Unique>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/unique.go#L13" target="_blank">Source</a> |
| [type Number](<#Number>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L9-L13" target="_blank">Source</a> |
| [type NumericCollection](<#NumericCollection>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L22-L24" target="_blank">Source</a> |
| [NewNumeric](<#NewNumeric>) | type NumericCollection | Type Function | <a href="https://github.com/goforj/collection/blob/main/collection.go#L28" target="_blank">Source</a> |
| [Avg](<#NumericCollection[T].Avg>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/avg.go#L17" target="_blank">Source</a> |
| [Max](<#NumericCollection[T].Max>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/max.go#L32" target="_blank">Source</a> |
| [Median](<#NumericCollection[T].Median>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/median.go#L14" target="_blank">Source</a> |
| [Min](<#NumericCollection[T].Min>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/min.go#L10" target="_blank">Source</a> |
| [Mode](<#NumericCollection[T].Mode>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/mode.go#L12" target="_blank">Source</a> |
| [Sum](<#NumericCollection[T].Sum>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/sum.go#L15" target="_blank">Source</a> |


<a name="CountBy"></a>
## CountBy


CountBy returns a map of keys extracted by fn to their occurrence counts. K must be comparable.

Example:

```go
// integers
c := collection.New([]int{1, 2, 2, 3, 3, 3})
counts := collection.CountBy(c, func(v int) int {
	return v
})
collection.Dump(counts)
// map[int]int {
//   1: 1 #int
//   2: 2 #int
//   3: 3 #int
// }
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "apple", "cherry", "banana"})
counts2 := collection.CountBy(c2, func(v string) string {
	return v
})
collection.Dump(counts2)
// map[string]int {
//   "apple":  2 #int
//   "banana": 2 #int
//   "cherry": 1 #int
// }
```

Example:

```go
// structs
type User struct {
	Name string
	Role string
}

users := collection.New([]User{
	{Name: "Alice", Role: "admin"},
	{Name: "Bob",   Role: "user"},
	{Name: "Carol", Role: "admin"},
	{Name: "Dave",  Role: "user"},
	{Name: "Eve",   Role: "admin"},
})

roleCounts := collection.CountBy(users, func(u User) string {
	return u.Role
})

collection.Dump(roleCounts)
// map[string]int {
//   "admin": 3 #int
//   "user":  2 #int
// }
```



<a name="CountByValue"></a>
## CountByValue


CountByValue returns a map of item values to their occurrence counts. T must be comparable. Example:

```go
counts := CountByValue(collection.New([]string{"a", "b", "a"}))
// counts == map[string]int{"a": 2, "b": 1}
```



<a name="Dump"></a>
## Dump


Dump is a convenience function that calls godump.Dump.

Example:

```go
// integers
c2 := collection.New([]int{1, 2, 3})
collection.Dump(c2.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```








<a name="MapTo"></a>
### MapTo


MapTo maps a Collection\[T\] to a Collection\[R\] using fn\(T\) R.

This cannot be a method because methods can't introduce a new type parameter R. Example:

```go
squared := numbers.MapTo(func(n int) int { return n * n })
// squared is a Collection[int] of squared numbers
```



<a name="New"></a>
### New


New wraps a slice in a Collection. A shallow copy is made so that further operations don't mutate the original slice.



<a name="Pluck"></a>
### Pluck


Pluck is an alias for MapTo with a more semantic name when projecting fields. Example:

```go
names := users.Pluck(func(u User) string { return u.Name })
// names is a Collection[string] of user names
```



<a name="TakeUntil"></a>
### TakeUntil


TakeUntil returns items until the first element equals \`value\`. The matching item is NOT included.

Uses == comparison, so T must be comparable.



<a name="Times"></a>
### Times


Times creates a new collection by running fn\(n\) for i from 1..count. This mirrors Laravel's Collection::times\(\), which is 1\-indexed.

Example:

```go
c := collection.Times(5, func(i int) int { return i * 2 })
// [2,4,6,8,10]
```





<a name="Collection[T].After"></a>
### After


After returns all items after the first element for which pred returns true. If no element matches, an empty collection is returned.

Example:

```go
c := collection.New([]int{1, 2, 3, 4, 5})
c.After(func(v int) bool { return v == 3 }).Dump()
// #[]int [
//  0 => 4 #int
//  1 => 5 #int
// ]
```



<a name="Collection[T].Any"></a>
### Any


Any returns true if at least one item satisfies fn. Example:

```go
c := collection.New([]int{1, 2, 3, 4})
has := c.Any(func(v int) bool { return v%2 == 0 }) // true
collection.Dump(has)
// true #bool
```



<a name="Collection[T].Append"></a>
### Append


Append returns a new collection with the given values appended. Example:

```go
// integers
c := collection.New([]int{1, 2})
c.Append(3, 4).Dump()
// #[]int [
//  0 => 1 #int
//  1 => 2 #int
//  2 => 3 #int
//  3 => 4 #int
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

users.Append(
	User{ID: 3, Name: "Carol"},
	User{ID: 4, Name: "Dave"},
).Dump()

// #[]main.User [
//  0 => #main.User {
//    +ID   => 1 #int
//    +Name => "Alice" #string
//  }
//  1 => #main.User {
//    +ID   => 2 #int
//    +Name => "Bob" #string
//  }
//  2 => #main.User {
//    +ID   => 3 #int
//    +Name => "Carol" #string
//  }
//  3 => #main.User {
//    +ID   => 4 #int
//    +Name => "Dave" #string
//  }
// ]
```



<a name="Collection[T].Before"></a>
### Before


Before returns all items before the first element for which pred returns true. If no element matches, the entire collection is returned.



<a name="Collection[T].Chunk"></a>
### Chunk


Chunk splits the collection into chunks of the given size. The final chunk may be smaller if len\(items\) is not divisible by size.

If size \<= 0, nil is returned. Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4, 5}).Chunk(2)
collection.Dump(c)

// #[][]int [
//  0 => #[]int [
//    0 => 1 #int
//    1 => 2 #int
//  ]
//  1 => #[]int [
//    0 => 3 #int
//    1 => 4 #int
//  ]
//  2 => #[]int [
//    0 => 5 #int
//  ]
//]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := []User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Carol"},
	{ID: 4, Name: "Dave"},
}

userChunks := collection.New(users).Chunk(2)
collection.Dump(userChunks)

// Example Dump output will show [][]User grouped in size-2 chunks, e.g.:
// #[][]main.User [
//  0 => #[]main.User [
//    0 => #main.User {
//      +ID   => 1 #int
//      +Name => "Alice" #string
//    }
//    1 => #main.User {
//      +ID   => 2 #int
//      +Name => "Bob" #string
//    }
//  ]
//  1 => #[]main.User [
//    0 => #main.User {
//      +ID   => 3 #int
//      +Name => "Carol" #string
//    }
//    1 => #main.User {
//      +ID   => 4 #int
//      +Name => "Dave" #string
//    }
//  ]
//]
```



<a name="Collection[T].Concat"></a>
### Concat


Concat appends the values from the given slice onto the end of the collection, returning a new collection. The original collection is never modified.

This mirrors Laravel's concat\(\): the appended values are numerically reindexed in the resulting collection, regardless of their original keys or positions.

Example:

```go
c := collection.New([]string{"John Doe"})
concatenated := c.
	Concat([]string{"Jane Doe"}).
	Concat([]string{"Johnny Doe"}).
	Items()
collection.Dump(concatenated)

// #[]string [
//  0 => "John Doe" #string
//  1 => "Jane Doe" #string
//  2 => "Johnny Doe" #string
// ]
```



<a name="Collection[T].Contains"></a>
### Contains


Contains returns true if any item satisfies the predicate. Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4, 5})
hasEven := c.Contains(func(v int) bool {
	return v%2 == 0
})
collection.Dump(hasEven)
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})
hasBanana := c2.Contains(func(v string) bool {
	return v == "banana"
})
collection.Dump(hasBanana)
// true #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Carol"},
})

hasBob := users.Contains(func(u User) bool {
	return u.Name == "Bob"
})
collection.Dump(hasBob)
// true #bool
```



<a name="Collection[T].Count"></a>
### Count


Count returns the total number of items in the collection. Example:

```go
count := collection.New([]int{1, 2, 3, 4}).Count()
collection.Dump(count)
// 4 #int
```



<a name="Collection[T].Dd"></a>
### Dd


Dd prints items then terminates execution. Like Laravel's dd\(\), this is intended for debugging and should not be used in production control flow.

This method never returns.

Example:

```go
// strings
c := collection.New([]string{"a", "b"})
c.Dd()
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
// ]
// Process finished with the exit code 1
```



<a name="Collection[T].Dump"></a>
### Dump


Dump prints items with godump and returns the same collection. This is a no\-op on the collection itself and never panics.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})
c.Dump()
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```

Example:

```go
// chaining
collection.New([]int{1, 2, 3}).
	Filter(func(v int) bool { return v > 1 }).
	Dump()
// #[]int [
//   0 => 2 #int
//   1 => 3 #int
// ]
```



<a name="Collection[T].DumpStr"></a>
### DumpStr


DumpStr returns the pretty\-printed dump of the items as a string, without printing or exiting. Useful for logging, snapshot testing, and non\-interactive debugging.

Example:

```go
// integers
c := collection.New([]int{10, 20})
s := c.DumpStr()
fmt.Println(s)
// #[]int [
//   0 => 10 #int
//   1 => 20 #int
// ]
```



<a name="Collection[T].Each"></a>
### Each


Each runs fn for every item in the collection and returns the same collection, so it can be used in chains for side effects \(logging, debugging, etc.\).

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})

sum := 0
c.Each(func(v int) {
	sum += v
})

collection.Dump(sum)
// 6 #int
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})

var out []string
c2.Each(func(s string) {
	out = append(out, strings.ToUpper(s))
})

collection.Dump(out)
// #[]string [
//   0 => "APPLE"  #string
//   1 => "BANANA" #string
//   2 => "CHERRY" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Charlie"},
})

var names []string
users.Each(func(u User) {
	names = append(names, u.Name)
})

collection.Dump(names)
// #[]string [
//   0 => "Alice"   #string
//   1 => "Bob"     #string
//   2 => "Charlie" #string
// ]
```



<a name="Collection[T].Filter"></a>
### Filter


Filter keeps only the elements for which fn returns true. This method mutates the collection in place and returns the same instance.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4})
c.Filter(func(v int) bool {
	return v%2 == 0
})
collection.Dump(c.Items())
// #[]int [
//   0 => 2 #int
//   1 => 4 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry", "avocado"})
c2.Filter(func(v string) bool {
	return strings.HasPrefix(v, "a")
})
collection.Dump(c2.Items())
// #[]string [
//   0 => "apple" #string
//   1 => "avocado" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Andrew"},
	{ID: 4, Name: "Carol"},
})

users.Filter(func(u User) bool {
	return strings.HasPrefix(u.Name, "A")
})

collection.Dump(users.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +ID   => 3 #int
//     +Name => "Andrew" #string
//   }
// ]
```



<a name="Collection[T].FindWhere"></a>
### FindWhere


FindWhere returns the first item in the collection for which the provided predicate function returns true. This method is an alias for FirstWhere\(fn\) and is provided for ergonomic parity with functional libraries and languages such as JavaScript, Rust, C\#, and Python.

FindWhere improves discoverability for developers who naturally search for a "find" helper when retrieving an element that matches a condition.

Examples:

```go
nums := New([]int{1, 2, 3, 4, 5})

v, ok := nums.FindWhere(func(n int) bool {
    return n == 3
})
// v = 3, ok = true

v, ok = nums.FindWhere(func(n int) bool {
    return n > 10
})
// v = 0, ok = false
```



<a name="Collection[T].First"></a>
### First


First returns the first element in the collection. If the collection is empty, ok will be false.

Example:

```go
// integers
c := collection.New([]int{10, 20, 30})

v, ok := c.First()
collection.Dump(v, ok)
// 10   #int
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"alpha", "beta", "gamma"})

v2, ok2 := c2.First()
collection.Dump(v2, ok2)
// "alpha" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

u, ok3 := users.First()
collection.Dump(u, ok3)
// #main.User {
//   +ID   => 1      #int
//   +Name => "Alice" #string
// }
// true #bool
```

Example:

```go
// empty collection
c3 := collection.New([]int{})
v3, ok4 := c3.First()
collection.Dump(v3, ok4)
// 0    #int
// false #bool
```



<a name="Collection[T].FirstWhere"></a>
### FirstWhere


FirstWhere returns the first item in the collection for which the provided predicate function returns true. If no items match, ok=false is returned along with the zero value of T.

This method is equivalent to Laravel's collection\-\>first\(fn\) and mirrors the behavior found in functional collections in other languages.

Examples:

```go
nums := New([]int{1, 2, 3, 4, 5})
v, ok := nums.FirstWhere(func(n int) bool {
    return n%2 == 0
})
// v = 2, ok = true

v, ok = nums.FirstWhere(func(n int) bool {
    return n > 10
})
// v = 0, ok = false
```



<a name="Collection[T].IsEmpty"></a>
### IsEmpty


IsEmpty returns true if the collection has no items.

Example:

```go
// integers (non-empty)
c := collection.New([]int{1, 2, 3})

empty := c.IsEmpty()
collection.Dump(empty)
// false #bool
```

Example:

```go
// strings (empty)
c2 := collection.New([]string{})

empty2 := c2.IsEmpty()
collection.Dump(empty2)
// true #bool
```

Example:

```go
// structs (non-empty)
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
})

empty3 := users.IsEmpty()
collection.Dump(empty3)
// false #bool
```

Example:

```go
// structs (empty)
none := collection.New([]User{})

empty4 := none.IsEmpty()
collection.Dump(empty4)
// true #bool
```



<a name="Collection[T].Items"></a>
### Items


Items returns the underlying slice of items.



<a name="Collection[T].Last"></a>
### Last


Last returns the last element in the collection. If the collection is empty, ok will be false.

Example:

```go
// integers
c := collection.New([]int{10, 20, 30})

v, ok := c.Last()
collection.Dump(v, ok)
// 30   #int
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"alpha", "beta", "gamma"})

v2, ok2 := c2.Last()
collection.Dump(v2, ok2)
// "gamma" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Charlie"},
})

u, ok3 := users.Last()
collection.Dump(u, ok3)
// #main.User {
//   +ID   => 3         #int
//   +Name => "Charlie" #string
// }
// true #bool
```

Example:

```go
// empty collection
c3 := collection.New([]int{})

v3, ok4 := c3.Last()
collection.Dump(v3, ok4)
// 0     #int
// false #bool
```



<a name="Collection[T].LastWhere"></a>
### LastWhere


LastWhere returns the last element in the collection that satisfies the predicate fn. If fn is nil, LastWhere returns the final element in the underlying slice. If the collection is empty or no element matches, ok will be false.

Example:

```go
// integers with predicate
c := collection.New([]int{1, 2, 3, 4})

v, ok := c.LastWhere(func(v int, i int) bool {
	return v < 3
})
collection.Dump(v, ok)
// 2    #int
// true #bool
```

Example:

```go
// integers without predicate (equivalent to Last())
c2 := collection.New([]int{10, 20, 30, 40})

v2, ok2 := c2.LastWhere(nil)
collection.Dump(v2, ok2)
// 40   #int
// true #bool
```

Example:

```go
// strings
c3 := collection.New([]string{"alpha", "beta", "gamma", "delta"})

v3, ok3 := c3.LastWhere(func(s string, i int) bool {
	return strings.HasPrefix(s, "g")
})
collection.Dump(v3, ok3)
// "gamma" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Alex"},
	{ID: 4, Name: "Brian"},
})

u, ok4 := users.LastWhere(func(u User, i int) bool {
	return strings.HasPrefix(u.Name, "A")
})
collection.Dump(u, ok4)
// #main.User {
//   +ID   => 3        #int
//   +Name => "Alex"  #string
// }
// true #bool
```

Example:

```go
// no matching element
c4 := collection.New([]int{5, 6, 7})

v4, ok5 := c4.LastWhere(func(v int, i int) bool {
	return v > 10
})
collection.Dump(v4, ok5)
// 0     #int
// false #bool
```

Example:

```go
// empty collection
c5 := collection.New([]int{})

v5, ok6 := c5.LastWhere(nil)
collection.Dump(v5, ok6)
// 0     #int
// false #bool
```



<a name="Collection[T].Map"></a>
### Map


Map applies a same\-type transformation and returns a new collection.

Use this when you're transforming T \-\> T \(e.g., enrichment, normalization\).

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})

mapped := c.Map(func(v int) int {
	return v * 10
})

collection.Dump(mapped.Items())
// #[]int [
//   0 => 10 #int
//   1 => 20 #int
//   2 => 30 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})

upper := c2.Map(func(s string) string {
	return strings.ToUpper(s)
})

collection.Dump(upper.Items())
// #[]string [
//   0 => "APPLE"  #string
//   1 => "BANANA" #string
//   2 => "CHERRY" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

updated := users.Map(func(u User) User {
	u.Name = strings.ToUpper(u.Name)
	return u
})

collection.Dump(updated.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1        #int
//     +Name => "ALICE"  #string
//   }
//   1 => #main.User {
//     +ID   => 2        #int
//     +Name => "BOB"    #string
//   }
// ]
```



<a name="Collection[T].Merge"></a>
### Merge


Merge merges the given data into the current collection using Laravel\-style semantics.

Behavior depends on the type of \`other\`:

- \[\]T \(numeric merges\) Values are appended to the end of the collection.
- Collection\[T\] Values are appended, same as merging a slice.
- map\[string\]T \(associative merges\) Keys that already exist overwrite the original values; new keys are added.

Unsupported merge types are ignored. This method never panics and always returns a new Collection.



<a name="Collection[T].Multiply"></a>
### Multiply


Multiply creates \`n\` copies of all items in the collection and returns a new collection.

Example:

```go
users := collection.New([]User{{Name: "A"}, {Name: "B"}})
 out := users.Multiply(3)
	// [A, B, A, B, A, B]
```

If n \<= 0, the method returns an empty collection.



<a name="Collection[T].Pipe"></a>
### Pipe


Pipe passes the entire collection into the given function and returns the function's result.

This is useful for inline transformations, aggregations, or "exiting" a chain with a non\-collection value.

Example:

```go
c := New([]int{1, 2, 3})
sum := c.Pipe(func(col Collection[int]) any {
    return col.Sum()
})

// sum == 6
```



<a name="Collection[T].Pop"></a>
### Pop


Pop returns the last item and a new collection with that item removed. The original collection remains unchanged.

If the collection is empty, the zero value of T is returned along with an empty collection.



<a name="Collection[T].PopN"></a>
### PopN


PopN removes and returns the last n items as a new collection, and returns a second collection containing the remaining items.



<a name="Collection[T].Prepend"></a>
### Prepend


Prepend returns a new collection with the given values prepended. Example:

```go
c := collection.New([]int{3, 4})
newC := c.Prepend(1, 2) // Collection with items [1, 2, 3, 4]
// newC.Items() == []int{1, 2, 3, 4}
```



<a name="Collection[T].Push"></a>
### Push


Push returns a new collection with the given values appended.

Examples:

```go
// Simple type (ints)
nums := collection.New([]int{1, 2}).Push(3, 4)
// nums = [1, 2, 3, 4]

// Complex type (structs)
type User struct {
    Name string
    Age  int
}

users := collection.New([]User{
    {Name: "Alice", Age: 30},
    {Name: "Bob",   Age: 25},
}).Push(
    User{Name: "Carol", Age: 40},
    User{Name: "Dave",  Age: 20},
)

// users = [
//   {Alice 30},
//   {Bob 25},
//   {Carol 40},
//   {Dave 20},
// ]
```



<a name="Collection[T].Reduce"></a>
### Reduce


Reduce collapses the collection into a single value of type T. The accumulator has the same type as the elements.

Example:

```go
// Sum of integers
sum := collection.New([]int{1, 2, 3}).Reduce(0, func(acc, n int) int {
	return acc + n
})
collection.Dump(sum)
// 6 #int

// Concatenate strings
joined := collection.New([]string{"a", "b", "c"}).Reduce("", func(acc, s string) string {
	return acc + s
})
collection.Dump(joined)
// "abc" #string

// Aggregate struct fields
type Stats struct {
	Count int
	Sum   int
}

c := collection.New([]Stats{
	{Count: 1, Sum: 10},
	{Count: 1, Sum: 20},
	{Count: 1, Sum: 30},
})

total := c.Reduce(Stats{}, func(acc, s Stats) Stats {
	acc.Count += s.Count
	acc.Sum += s.Sum
	return acc
})

collection.Dump(total)

// #main.Stats {
//  +Count => 3 #int
//  +Sum   => 60 #int
// }
```



<a name="Collection[T].Sort"></a>
### Sort


Sort returns a new collection sorted using the given comparison function.

less should return true if a should come before b.

Example:

```go
sorted := users.Sort(func(a, b User) bool { return a.Age < b.Age })
// sorted by Age ascending
```



<a name="Collection[T].Take"></a>
### Take


Take returns a new collection containing the first \`n\` items when n \> 0, or the last \`|n|\` items when n \< 0. If n exceeds the collection length, the entire slice \(or nothing\) is returned.

Mirrors Laravel's take\(\) semantics.

Examples:

```go
New([]int{0,1,2,3,4,5}).Take(3)  ‚Üí [0,1,2]
New([]int{0,1,2,3,4,5}).Take(-2) ‚Üí [4,5]
```



<a name="Collection[T].TakeUntilFn"></a>
### TakeUntilFn


TakeUntilFn returns items until the predicate function returns true. The matching item is NOT included. Example:

```go
c := collection.New([]int{1, 2, 3, 4})
out := c.TakeUntilFn(func(v int) bool { return v >= 3 }) // [1, 2]
```

// result is \[1, 2\]



<a name="Collection[T].Tap"></a>
### Tap


Tap invokes fn with the collection pointer for side effects \(logging, debugging, inspection\) and returns the same collection to allow chaining.

Tap does NOT modify the collection itself; it simply exposes the current state during a fluent chain.

Example:

```go
captured := []int{}
c := New([]int{3,1,2}).
    Sort(func(a,b int) bool { return a < b }).  // ‚Üí [1,2,3]
    Tap(func(col *Collection[int]) {
        captured = append([]int(nil), col.items...) // snapshot
    }).
    Filter(func(v int) bool { return v >= 2 })     // ‚Üí [2,3]
```

After Tap, 'captured' contains the sorted state: \[\]int\{1,2,3\} and the chain continues unaffected.



<a name="Collection[T].ToJSON"></a>
### ToJSON


ToJSON converts the collection's items into a compact JSON string.

If marshalling succeeds, a JSON\-encoded string and a nil error are returned. If marshalling fails, the method unwraps any json.Marshal wrapping so that user\-defined MarshalJSON errors surface directly.

This method never panics.

Example:

```go
c := collection.New([]int{1, 2, 3})
out, err := c.ToJSON()
// out: "[1,2,3]"
// err: nil
```

Example \(error\):

```go
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the JSON\-encoded representation of the collection
- error : nil on success, or the unwrapped marshalling error



<a name="Collection[T].ToPrettyJSON"></a>
### ToPrettyJSON


ToPrettyJSON converts the collection's items into an indented, human\-readable JSON string.

If marshalling succeeds, a formatted JSON string and nil error are returned. If marshalling fails, the underlying error is unwrapped so that user\-defined MarshalJSON failures surface directly \(e.g., "marshal failure"\) rather than the json.MarshalIndent wrapper.

This method never panics.

Example:

```go
c := collection.New([]string{"a", "b"})
out, err := c.ToPrettyJSON()
// out:
// [
//   "a",
//   "b"
// ]
// err: nil
```

Example \(error\):

```go
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToPrettyJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the pretty\-printed JSON representation
- error : nil on success, or the unwrapped marshalling error



<a name="Collection[T].Transform"></a>
### Transform


Transform applies fn to every item \*in place\* and replaces the values with the returned values. This matches Laravel's transform\(\), which mutates the collection instead of returning a new one. Example:

```go
c := collection.New([]int{1,2,3})
c.Transform(func(v int) int { return v * 2 })
// c is now [2,4,6]
```



<a name="Collection[T].Unique"></a>
### Unique


Unique returns a collection with duplicate items \(according to eq\) removed, preserving the first occurrence of each unique value.

eq should return true if the two values are considered equal. Example usage:

```go
c := collection.New([]int{1, 2, 2, 3, 4, 4, 5})
unique := c.Unique(func(a, b int) bool { return a == b })

// result: [1, 2, 3, 4, 5]
```

















<a name="NewNumeric"></a>
### NewNumeric


NewNumeric wraps a slice of numeric types in a NumericCollection. A shallow copy is made so that further operations don't mutate the original slice.





<a name="NumericCollection[T].Avg"></a>
### Avg


Avg returns the average of the collection values as a float64. If the collection is empty, Avg returns 0.

Example: int

```go
// int
c := collection.NewNumeric([]int{2, 4, 6})
collection.Dump(c.Avg())
// 4.000000 #float64
```

Example: float

```go
// float64
c2 := collection.NewNumeric([]float64{1.5, 2.5, 3.0})
collection.Dump(c2.Avg())
// 2.333333 #float64
```



<a name="NumericCollection[T].Max"></a>
### Max


Max returns the largest numeric item in the collection. The second return value is false if the collection is empty.

Example:

```go
// integers
c := collection.NewNumeric([]int{3, 1, 2})

max1, ok1 := c.Max()
collection.Dump(max1, ok1)
// 3    #int
// true #bool
```

Example:

```go
// floats
c2 := collection.NewNumeric([]float64{1.5, 9.2, 4.4})

max2, ok2 := c2.Max()
collection.Dump(max2, ok2)
// 9.200000 #float64
// true     #bool
```

Example:

```go
// empty numeric collection
c3 := collection.NewNumeric([]int{})

max3, ok3 := c3.Max()
collection.Dump(max3, ok3)
// 0     #int
// false #bool
```



<a name="NumericCollection[T].Median"></a>
### Median


Median returns the statistical median of the numeric collection as float64. Returns \(0, false\) if the collection is empty.

Odd count ‚Üí middle value Even count ‚Üí average of the two middle values

Example:

```go
c := collection.NewNumeric([]int{3, 1, 2})
median, ok := c.Median()   // ‚Üí 2, true
```



<a name="NumericCollection[T].Min"></a>
### Min


Min returns the smallest numeric item in the collection. The second return value is false if the collection is empty.

Example:

```go
c := collection.NewNumeric([]int{3, 1, 2})
 min, ok := c.Min()
	1, true
```



<a name="NumericCollection[T].Mode"></a>
### Mode


Mode returns the most frequent numeric value\(s\) in the collection. If multiple values tie for highest frequency, all are returned in first\-seen order.

Example:

```go
collection.NewNumeric([]int{1, 2, 2, 3}).Mode() // ‚Üí []int{2}
```

Example \(tie\):

```go
collection.NewNumeric([]int{1, 2, 1, 2}).Mode() // ‚Üí []int{1, 2}
```



<a name="NumericCollection[T].Sum"></a>
### Sum


Sum returns the sum of all numeric items in the NumericCollection. If the collection is empty, Sum returns the zero value of T.

Example:

```go
c := collection.NewNumeric([]int{1, 2, 3})
total := c.Sum()
// total == 6
```

Example \(float\):

```go
c := collection.NewNumeric([]float64{1.5, 2.5})
total := c.Sum()
// total == 4.0
```




Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->