<p align="center">
  <img src="./docs/assets/logo.png" width="600" alt="goforj/collection logo">
</p>

<p align="center">
    Fluent, Laravel-style Collections for Go - with generics, chainable pipelines, and expressive data transforms.
</p>

<p align="center">
    <a href="https://pkg.go.dev/github.com/goforj/collection"><img src="https://pkg.go.dev/badge/github.com/goforj/collection.svg" alt="Go Reference"></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License: MIT"></a>
    <a href="https://github.com/goforj/collection/actions"><img src="https://github.com/goforj/collection/actions/workflows/test.yml/badge.svg" alt="Go Test"></a>
    <a href="https://golang.org"><img src="https://img.shields.io/badge/go-1.21+-blue?logo=go" alt="Go version"></a>
    <img src="https://img.shields.io/github/v/tag/goforj/collection?label=version&sort=semver" alt="Latest tag">
    <a href="https://codecov.io/gh/goforj/collection" ><img src="https://codecov.io/github/goforj/collection/graph/badge.svg?token=3KFTK96U8C"/></a>
    <a href="https://goreportcard.com/report/github.com/goforj/collection"><img src="https://goreportcard.com/badge/github.com/goforj/collection" alt="Go Report Card"></a>
</p>

<p align="center">
  <code>collection</code> brings an expressive, fluent API to Go.  
  Iterate, filter, transform, sort, reduce, group, and debug your data with zero dependencies.  
  Designed to feel natural to Go developers - and luxurious to everyone else.
</p>

# Features

- üîó **Fluent chaining** - pipeline your operations like Laravel Collections
- üß¨ **Fully generic** (`Collection[T]`) - no reflection, no `interface{}`
- ‚ö° **Zero dependencies** - pure Go, fast, lightweight
- üßµ **Minimal allocations** - avoids unnecessary copies; most operations reuse the underlying slice
- üßπ **Map / Filter / Reduce** - clean functional transforms
- üîç **First / Last / Find / Contains** helpers
- üìè **Sort, GroupBy, Chunk**, and more
- üß™ **Safe-by-default** - defensive copies where appropriate
- üìú **Built-in JSON helpers** (`ToJSON()`, `ToPrettyJSON()`)
- üß∞ **Developer-friendly debug helpers** (`Dump()`, `Dd()`, `DumpStr()`, `DdStr()`)
- üß± **Works with any Go type**, including structs, pointers, and deeply nested composites

# üì¶ Installation

```bash
go get github.com/goforj/collection
```

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# collection

```go
import "github.com/goforj/collection"
```

## Index

| Name | Parent | Kind | Source |
|------|--------|-------|--------|
| [CountBy](<#CountBy>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/count_by.go#L56" target="_blank">Source</a> |
| [CountByValue](<#CountByValue>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/count_by.go#L70" target="_blank">Source</a> |
| [Dump](<#Dump>) |  | Function | <a href="https://github.com/goforj/collection/blob/main/dump.go#L95" target="_blank">Source</a> |
| [type Collection](<#Collection>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L4-L6" target="_blank">Source</a> |
| [MapTo](<#MapTo>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/pluck.go#L58" target="_blank">Source</a> |
| [New](<#New>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/collection.go#L24" target="_blank">Source</a> |
| [Pluck](<#Pluck>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/pluck.go#L122" target="_blank">Source</a> |
| [TakeUntil](<#TakeUntil>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/take_until.go#L27" target="_blank">Source</a> |
| [Times](<#Times>) | type Collection | Type Function | <a href="https://github.com/goforj/collection/blob/main/times.go#L9" target="_blank">Source</a> |
| [After](<#Collection[T].After>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/after.go#L13" target="_blank">Source</a> |
| [Any](<#Collection[T].Any>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/any.go#L9" target="_blank">Source</a> |
| [Append](<#Collection[T].Append>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/append.go#L50" target="_blank">Source</a> |
| [Before](<#Collection[T].Before>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/before.go#L5" target="_blank">Source</a> |
| [Chunk](<#Collection[T].Chunk>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/chunk.go#L66" target="_blank">Source</a> |
| [Concat](<#Collection[T].Concat>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/concat.go#L22" target="_blank">Source</a> |
| [Contains](<#Collection[T].Contains>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/contains.go#L40" target="_blank">Source</a> |
| [Count](<#Collection[T].Count>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/count.go#L8" target="_blank">Source</a> |
| [Dd](<#Collection[T].Dd>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L54" target="_blank">Source</a> |
| [Dump](<#Collection[T].Dump>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L34" target="_blank">Source</a> |
| [DumpStr](<#Collection[T].DumpStr>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/dump.go#L71" target="_blank">Source</a> |
| [Each](<#Collection[T].Each>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/each.go#L58" target="_blank">Source</a> |
| [Filter](<#Collection[T].Filter>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/filter.go#L59" target="_blank">Source</a> |
| [FindWhere](<#Collection[T].FindWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/find_where.go#L59" target="_blank">Source</a> |
| [First](<#Collection[T].First>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/first.go#L51" target="_blank">Source</a> |
| [FirstWhere](<#Collection[T].FirstWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/first_where.go#L23" target="_blank">Source</a> |
| [IsEmpty](<#Collection[T].IsEmpty>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/is_empty.go#L43" target="_blank">Source</a> |
| [Items](<#Collection[T].Items>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/collection.go#L88" target="_blank">Source</a> |
| [Last](<#Collection[T].Last>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/last.go#L53" target="_blank">Source</a> |
| [LastWhere](<#Collection[T].LastWhere>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/last_where.go#L81" target="_blank">Source</a> |
| [Map](<#Collection[T].Map>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/map.go#L65" target="_blank">Source</a> |
| [Merge](<#Collection[T].Merge>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/merge.go#L70" target="_blank">Source</a> |
| [Multiply](<#Collection[T].Multiply>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/multiply.go#L62" target="_blank">Source</a> |
| [Pipe](<#Collection[T].Pipe>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pipe.go#L60" target="_blank">Source</a> |
| [Pop](<#Collection[T].Pop>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pop.go#L64" target="_blank">Source</a> |
| [PopN](<#Collection[T].PopN>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/pop.go#L167" target="_blank">Source</a> |
| [Prepend](<#Collection[T].Prepend>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/prepend.go#L74" target="_blank">Source</a> |
| [Push](<#Collection[T].Push>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/append.go#L86" target="_blank">Source</a> |
| [Reduce](<#Collection[T].Reduce>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/reduce.go#L49" target="_blank">Source</a> |
| [Sort](<#Collection[T].Sort>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/sort.go#L67" target="_blank">Source</a> |
| [Take](<#Collection[T].Take>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/take.go#L12" target="_blank">Source</a> |
| [TakeUntilFn](<#Collection[T].TakeUntilFn>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/take_until.go#L10" target="_blank">Source</a> |
| [Tap](<#Collection[T].Tap>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/tap.go#L21" target="_blank">Source</a> |
| [ToJSON](<#Collection[T].ToJSON>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/to_json.go#L38" target="_blank">Source</a> |
| [ToPrettyJSON](<#Collection[T].ToPrettyJSON>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/to_json.go#L82" target="_blank">Source</a> |
| [Transform](<#Collection[T].Transform>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/transform.go#L10" target="_blank">Source</a> |
| [Unique](<#Collection[T].Unique>) | type Collection | Method | <a href="https://github.com/goforj/collection/blob/main/unique.go#L13" target="_blank">Source</a> |
| [type Number](<#Number>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L9-L13" target="_blank">Source</a> |
| [type NumericCollection](<#NumericCollection>) |  | Type | <a href="https://github.com/goforj/collection/blob/main/collection.go#L29-L31" target="_blank">Source</a> |
| [NewNumeric](<#NewNumeric>) | type NumericCollection | Type Function | <a href="https://github.com/goforj/collection/blob/main/collection.go#L35" target="_blank">Source</a> |
| [Avg](<#NumericCollection[T].Avg>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/avg.go#L17" target="_blank">Source</a> |
| [Max](<#NumericCollection[T].Max>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/max.go#L32" target="_blank">Source</a> |
| [Median](<#NumericCollection[T].Median>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/median.go#L46" target="_blank">Source</a> |
| [Min](<#NumericCollection[T].Min>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/min.go#L29" target="_blank">Source</a> |
| [Mode](<#NumericCollection[T].Mode>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/mode.go#L41" target="_blank">Source</a> |
| [Sum](<#NumericCollection[T].Sum>) | type NumericCollection | Method | <a href="https://github.com/goforj/collection/blob/main/sum.go#L26" target="_blank">Source</a> |


<a name="CountBy"></a>
## CountBy


CountBy returns a map of keys extracted by fn to their occurrence counts. K must be comparable.

Example:

```go
// integers
c := collection.New([]int{1, 2, 2, 3, 3, 3})
counts := collection.CountBy(c, func(v int) int {
	return v
})
collection.Dump(counts)
// map[int]int {
//   1: 1 #int
//   2: 2 #int
//   3: 3 #int
// }
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "apple", "cherry", "banana"})
counts2 := collection.CountBy(c2, func(v string) string {
	return v
})
collection.Dump(counts2)
// map[string]int {
//   "apple":  2 #int
//   "banana": 2 #int
//   "cherry": 1 #int
// }
```

Example:

```go
// structs
type User struct {
	Name string
	Role string
}

users := collection.New([]User{
	{Name: "Alice", Role: "admin"},
	{Name: "Bob",   Role: "user"},
	{Name: "Carol", Role: "admin"},
	{Name: "Dave",  Role: "user"},
	{Name: "Eve",   Role: "admin"},
})

roleCounts := collection.CountBy(users, func(u User) string {
	return u.Role
})

collection.Dump(roleCounts)
// map[string]int {
//   "admin": 3 #int
//   "user":  2 #int
// }
```



<a name="CountByValue"></a>
## CountByValue


CountByValue returns a map of item values to their occurrence counts. T must be comparable. Example:

```go
counts := CountByValue(collection.New([]string{"a", "b", "a"}))
// counts == map[string]int{"a": 2, "b": 1}
```



<a name="Dump"></a>
## Dump


Dump is a convenience function that calls godump.Dump.

Example:

```go
// integers
c2 := collection.New([]int{1, 2, 3})
collection.Dump(c2.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```








<a name="MapTo"></a>
### MapTo


MapTo maps a Collection\[T\] to a Collection\[R\] using fn\(T\) R.

This cannot be a method because methods can't introduce a new type parameter R.

Example:

```go
// integers ‚Üí extract parity label
nums := collection.New([]int{1, 2, 3, 4})
parity := collection.MapTo(nums, func(n int) string {
	if n%2 == 0 {
		return "even"
	}
	return "odd"
})
collection.Dump(parity.Items())
// #[]string [
//   0 => "odd" #string
//   1 => "even" #string
//   2 => "odd" #string
//   3 => "even" #string
// ]
```

Example:

```go
// strings ‚Üí length of each value
words := collection.New([]string{"go", "forj", "rocks"})
lengths := collection.MapTo(words, func(s string) int {
	return len(s)
})
collection.Dump(lengths.Items())
// #[]int [
//   0 => 2 #int
//   1 => 4 #int
//   2 => 5 #int
// ]
```

Example:

```go
// structs ‚Üí MapTo a field
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

names := collection.MapTo(users, func(u User) string {
	return u.Name
})

collection.Dump(names.Items())
// #[]string [
//   0 => "Alice" #string
//   1 => "Bob" #string
// ]
```



<a name="New"></a>
### New


New creates a new Collection from the provided slice.

The returned Collection is a lightweight, strongly\-typed wrapper around the slice, enabling fluent, chainable operations such as filtering, mapping, reducing, sorting, and more.

The underlying slice is stored as\-is \(no copy is made\), allowing New to be both fast and allocation\-friendly. Callers should clone the input beforehand if they need to prevent shared mutation.



<a name="Pluck"></a>
### Pluck


Pluck is an alias for MapTo with a more semantic name when projecting fields. It extracts a single field or computed value from every element and returns a new typed collection.

Example:

```go
// integers ‚Üí extract parity label
nums := collection.New([]int{1, 2, 3, 4})
parity := collection.Pluck(nums, func(n int) string {
	if n%2 == 0 {
		return "even"
	}
	return "odd"
})
collection.Dump(parity.Items())
// #[]string [
//   0 => "odd" #string
//   1 => "even" #string
//   2 => "odd" #string
//   3 => "even" #string
// ]
```

Example:

```go
// strings ‚Üí length of each value
words := collection.New([]string{"go", "forj", "rocks"})
lengths := collection.Pluck(words, func(s string) int {
	return len(s)
})
collection.Dump(lengths.Items())
// #[]int [
//   0 => 2 #int
//   1 => 4 #int
//   2 => 5 #int
// ]
```

Example:

```go
// structs ‚Üí pluck a field
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

names := collection.Pluck(users, func(u User) string {
	return u.Name
})

collection.Dump(names.Items())
// #[]string [
//   0 => "Alice" #string
//   1 => "Bob" #string
// ]
```



<a name="TakeUntil"></a>
### TakeUntil


TakeUntil returns items until the first element equals \`value\`. The matching item is NOT included.

Uses == comparison, so T must be comparable.



<a name="Times"></a>
### Times


Times creates a new collection by running fn\(n\) for i from 1..count. This mirrors Laravel's Collection::times\(\), which is 1\-indexed.

Example:

```go
c := collection.Times(5, func(i int) int { return i * 2 })
// [2,4,6,8,10]
```





<a name="Collection[T].After"></a>
### After


After returns all items after the first element for which pred returns true. If no element matches, an empty collection is returned.

Example:

```go
c := collection.New([]int{1, 2, 3, 4, 5})
c.After(func(v int) bool { return v == 3 }).Dump()
// #[]int [
//  0 => 4 #int
//  1 => 5 #int
// ]
```



<a name="Collection[T].Any"></a>
### Any


Any returns true if at least one item satisfies fn. Example:

```go
c := collection.New([]int{1, 2, 3, 4})
has := c.Any(func(v int) bool { return v%2 == 0 }) // true
collection.Dump(has)
// true #bool
```



<a name="Collection[T].Append"></a>
### Append


Append returns a new collection with the given values appended. Example:

```go
// integers
c := collection.New([]int{1, 2})
c.Append(3, 4).Dump()
// #[]int [
//  0 => 1 #int
//  1 => 2 #int
//  2 => 3 #int
//  3 => 4 #int
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

users.Append(
	User{ID: 3, Name: "Carol"},
	User{ID: 4, Name: "Dave"},
).Dump()

// #[]main.User [
//  0 => #main.User {
//    +ID   => 1 #int
//    +Name => "Alice" #string
//  }
//  1 => #main.User {
//    +ID   => 2 #int
//    +Name => "Bob" #string
//  }
//  2 => #main.User {
//    +ID   => 3 #int
//    +Name => "Carol" #string
//  }
//  3 => #main.User {
//    +ID   => 4 #int
//    +Name => "Dave" #string
//  }
// ]
```



<a name="Collection[T].Before"></a>
### Before


Before returns all items before the first element for which pred returns true. If no element matches, the entire collection is returned.



<a name="Collection[T].Chunk"></a>
### Chunk


Chunk splits the collection into chunks of the given size. The final chunk may be smaller if len\(items\) is not divisible by size.

If size \<= 0, nil is returned. Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4, 5}).Chunk(2)
collection.Dump(c)

// #[][]int [
//  0 => #[]int [
//    0 => 1 #int
//    1 => 2 #int
//  ]
//  1 => #[]int [
//    0 => 3 #int
//    1 => 4 #int
//  ]
//  2 => #[]int [
//    0 => 5 #int
//  ]
//]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := []User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Carol"},
	{ID: 4, Name: "Dave"},
}

userChunks := collection.New(users).Chunk(2)
collection.Dump(userChunks)

// Example Dump output will show [][]User grouped in size-2 chunks, e.g.:
// #[][]main.User [
//  0 => #[]main.User [
//    0 => #main.User {
//      +ID   => 1 #int
//      +Name => "Alice" #string
//    }
//    1 => #main.User {
//      +ID   => 2 #int
//      +Name => "Bob" #string
//    }
//  ]
//  1 => #[]main.User [
//    0 => #main.User {
//      +ID   => 3 #int
//      +Name => "Carol" #string
//    }
//    1 => #main.User {
//      +ID   => 4 #int
//      +Name => "Dave" #string
//    }
//  ]
//]
```



<a name="Collection[T].Concat"></a>
### Concat


Concat appends the values from the given slice onto the end of the collection, returning a new collection. The original collection is never modified.

This mirrors Laravel's concat\(\): the appended values are numerically reindexed in the resulting collection, regardless of their original keys or positions.

Example:

```go
c := collection.New([]string{"John Doe"})
concatenated := c.
	Concat([]string{"Jane Doe"}).
	Concat([]string{"Johnny Doe"}).
	Items()
collection.Dump(concatenated)

// #[]string [
//  0 => "John Doe" #string
//  1 => "Jane Doe" #string
//  2 => "Johnny Doe" #string
// ]
```



<a name="Collection[T].Contains"></a>
### Contains


Contains returns true if any item satisfies the predicate. Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4, 5})
hasEven := c.Contains(func(v int) bool {
	return v%2 == 0
})
collection.Dump(hasEven)
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})
hasBanana := c2.Contains(func(v string) bool {
	return v == "banana"
})
collection.Dump(hasBanana)
// true #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Carol"},
})

hasBob := users.Contains(func(u User) bool {
	return u.Name == "Bob"
})
collection.Dump(hasBob)
// true #bool
```



<a name="Collection[T].Count"></a>
### Count


Count returns the total number of items in the collection. Example:

```go
count := collection.New([]int{1, 2, 3, 4}).Count()
collection.Dump(count)
// 4 #int
```



<a name="Collection[T].Dd"></a>
### Dd


Dd prints items then terminates execution. Like Laravel's dd\(\), this is intended for debugging and should not be used in production control flow.

This method never returns.

Example:

```go
// strings
c := collection.New([]string{"a", "b"})
c.Dd()
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
// ]
// Process finished with the exit code 1
```



<a name="Collection[T].Dump"></a>
### Dump


Dump prints items with godump and returns the same collection. This is a no\-op on the collection itself and never panics.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})
c.Dump()
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```

Example:

```go
// chaining
collection.New([]int{1, 2, 3}).
	Filter(func(v int) bool { return v > 1 }).
	Dump()
// #[]int [
//   0 => 2 #int
//   1 => 3 #int
// ]
```



<a name="Collection[T].DumpStr"></a>
### DumpStr


DumpStr returns the pretty\-printed dump of the items as a string, without printing or exiting. Useful for logging, snapshot testing, and non\-interactive debugging.

Example:

```go
// integers
c := collection.New([]int{10, 20})
s := c.DumpStr()
fmt.Println(s)
// #[]int [
//   0 => 10 #int
//   1 => 20 #int
// ]
```



<a name="Collection[T].Each"></a>
### Each


Each runs fn for every item in the collection and returns the same collection, so it can be used in chains for side effects \(logging, debugging, etc.\).

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})

sum := 0
c.Each(func(v int) {
	sum += v
})

collection.Dump(sum)
// 6 #int
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})

var out []string
c2.Each(func(s string) {
	out = append(out, strings.ToUpper(s))
})

collection.Dump(out)
// #[]string [
//   0 => "APPLE"  #string
//   1 => "BANANA" #string
//   2 => "CHERRY" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Charlie"},
})

var names []string
users.Each(func(u User) {
	names = append(names, u.Name)
})

collection.Dump(names)
// #[]string [
//   0 => "Alice"   #string
//   1 => "Bob"     #string
//   2 => "Charlie" #string
// ]
```



<a name="Collection[T].Filter"></a>
### Filter


Filter keeps only the elements for which fn returns true. This method mutates the collection in place and returns the same instance.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3, 4})
c.Filter(func(v int) bool {
	return v%2 == 0
})
collection.Dump(c.Items())
// #[]int [
//   0 => 2 #int
//   1 => 4 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry", "avocado"})
c2.Filter(func(v string) bool {
	return strings.HasPrefix(v, "a")
})
collection.Dump(c2.Items())
// #[]string [
//   0 => "apple" #string
//   1 => "avocado" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Andrew"},
	{ID: 4, Name: "Carol"},
})

users.Filter(func(u User) bool {
	return strings.HasPrefix(u.Name, "A")
})

collection.Dump(users.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +ID   => 3 #int
//     +Name => "Andrew" #string
//   }
// ]
```



<a name="Collection[T].FindWhere"></a>
### FindWhere


FindWhere returns the first item in the collection for which the provided predicate function returns true. This is an alias for FirstWhere\(fn\) and exists for ergonomic parity with functional languages \(JavaScript, Rust, C\#, Python\) where developers expect a ‚Äúfind‚Äù helper.

Example:

```go
// simple match
nums := collection.New([]int{1, 2, 3, 4, 5})

v1, ok1 := nums.FindWhere(func(n int) bool {
	return n == 3
})
collection.Dump(v1, ok1)
// 3    #int
// true #bool
```

Example:

```go
// no match
v2, ok2 := nums.FindWhere(func(n int) bool {
	return n > 10
})
collection.Dump(v2, ok2)
// 0     #int
// false #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Charlie"},
})

u, ok3 := users.FindWhere(func(u User) bool {
	return u.ID == 2
})
collection.Dump(u, ok3)
// #collection.User {
//   +ID    => 2   #int
//   +Name  => "Bob" #string
// }
// true #bool
```

Example:

```go
// empty collection
empty := collection.New([]int{})

v4, ok4 := empty.FindWhere(func(n int) bool { return n == 1 })
collection.Dump(v4, ok4)
// 0     #int
// false #bool
```



<a name="Collection[T].First"></a>
### First


First returns the first element in the collection. If the collection is empty, ok will be false.

Example:

```go
// integers
c := collection.New([]int{10, 20, 30})

v, ok := c.First()
collection.Dump(v, ok)
// 10   #int
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"alpha", "beta", "gamma"})

v2, ok2 := c2.First()
collection.Dump(v2, ok2)
// "alpha" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

u, ok3 := users.First()
collection.Dump(u, ok3)
// #main.User {
//   +ID   => 1      #int
//   +Name => "Alice" #string
// }
// true #bool
```

Example:

```go
// empty collection
c3 := collection.New([]int{})
v3, ok4 := c3.First()
collection.Dump(v3, ok4)
// 0    #int
// false #bool
```



<a name="Collection[T].FirstWhere"></a>
### FirstWhere


FirstWhere returns the first item in the collection for which the provided predicate function returns true. If no items match, ok=false is returned along with the zero value of T.

This method is equivalent to Laravel's collection\-\>first\(fn\) and mirrors the behavior found in functional collections in other languages.

Examples:

```go
nums := New([]int{1, 2, 3, 4, 5})
v, ok := nums.FirstWhere(func(n int) bool {
    return n%2 == 0
})
// v = 2, ok = true

v, ok = nums.FirstWhere(func(n int) bool {
    return n > 10
})
// v = 0, ok = false
```



<a name="Collection[T].IsEmpty"></a>
### IsEmpty


IsEmpty returns true if the collection has no items.

Example:

```go
// integers (non-empty)
c := collection.New([]int{1, 2, 3})

empty := c.IsEmpty()
collection.Dump(empty)
// false #bool
```

Example:

```go
// strings (empty)
c2 := collection.New([]string{})

empty2 := c2.IsEmpty()
collection.Dump(empty2)
// true #bool
```

Example:

```go
// structs (non-empty)
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
})

empty3 := users.IsEmpty()
collection.Dump(empty3)
// false #bool
```

Example:

```go
// structs (empty)
none := collection.New([]User{})

empty4 := none.IsEmpty()
collection.Dump(empty4)
// true #bool
```



<a name="Collection[T].Items"></a>
### Items


Items returns the underlying slice of items.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})
items := c.Items()
collection.Dump(items)
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana"})
items2 := c2.Items()
collection.Dump(items2)
// #[]string [
//   0 => "apple" #string
//   1 => "banana" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

out := users.Items()
collection.Dump(out)
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +ID   => 2 #int
//     +Name => "Bob" #string
//   }
// ]
```



<a name="Collection[T].Last"></a>
### Last


Last returns the last element in the collection. If the collection is empty, ok will be false.

Example:

```go
// integers
c := collection.New([]int{10, 20, 30})

v, ok := c.Last()
collection.Dump(v, ok)
// 30   #int
// true #bool
```

Example:

```go
// strings
c2 := collection.New([]string{"alpha", "beta", "gamma"})

v2, ok2 := c2.Last()
collection.Dump(v2, ok2)
// "gamma" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Charlie"},
})

u, ok3 := users.Last()
collection.Dump(u, ok3)
// #main.User {
//   +ID   => 3         #int
//   +Name => "Charlie" #string
// }
// true #bool
```

Example:

```go
// empty collection
c3 := collection.New([]int{})

v3, ok4 := c3.Last()
collection.Dump(v3, ok4)
// 0     #int
// false #bool
```



<a name="Collection[T].LastWhere"></a>
### LastWhere


LastWhere returns the last element in the collection that satisfies the predicate fn. If fn is nil, LastWhere returns the final element in the underlying slice. If the collection is empty or no element matches, ok will be false.

Example:

```go
// integers with predicate
c := collection.New([]int{1, 2, 3, 4})

v, ok := c.LastWhere(func(v int, i int) bool {
	return v < 3
})
collection.Dump(v, ok)
// 2    #int
// true #bool
```

Example:

```go
// integers without predicate (equivalent to Last())
c2 := collection.New([]int{10, 20, 30, 40})

v2, ok2 := c2.LastWhere(nil)
collection.Dump(v2, ok2)
// 40   #int
// true #bool
```

Example:

```go
// strings
c3 := collection.New([]string{"alpha", "beta", "gamma", "delta"})

v3, ok3 := c3.LastWhere(func(s string, i int) bool {
	return strings.HasPrefix(s, "g")
})
collection.Dump(v3, ok3)
// "gamma" #string
// true    #bool
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Alex"},
	{ID: 4, Name: "Brian"},
})

u, ok4 := users.LastWhere(func(u User, i int) bool {
	return strings.HasPrefix(u.Name, "A")
})
collection.Dump(u, ok4)
// #main.User {
//   +ID   => 3        #int
//   +Name => "Alex"  #string
// }
// true #bool
```

Example:

```go
// no matching element
c4 := collection.New([]int{5, 6, 7})

v4, ok5 := c4.LastWhere(func(v int, i int) bool {
	return v > 10
})
collection.Dump(v4, ok5)
// 0     #int
// false #bool
```

Example:

```go
// empty collection
c5 := collection.New([]int{})

v5, ok6 := c5.LastWhere(nil)
collection.Dump(v5, ok6)
// 0     #int
// false #bool
```



<a name="Collection[T].Map"></a>
### Map


Map applies a same\-type transformation and returns a new collection.

Use this when you're transforming T \-\> T \(e.g., enrichment, normalization\).

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})

mapped := c.Map(func(v int) int {
	return v * 10
})

collection.Dump(mapped.Items())
// #[]int [
//   0 => 10 #int
//   1 => 20 #int
//   2 => 30 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"apple", "banana", "cherry"})

upper := c2.Map(func(s string) string {
	return strings.ToUpper(s)
})

collection.Dump(upper.Items())
// #[]string [
//   0 => "APPLE"  #string
//   1 => "BANANA" #string
//   2 => "CHERRY" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

updated := users.Map(func(u User) User {
	u.Name = strings.ToUpper(u.Name)
	return u
})

collection.Dump(updated.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1        #int
//     +Name => "ALICE"  #string
//   }
//   1 => #main.User {
//     +ID   => 2        #int
//     +Name => "BOB"    #string
//   }
// ]
```



<a name="Collection[T].Merge"></a>
### Merge


Merge merges the given data into the current collection.

Example: merging slices

```go
// integers
ints := collection.New([]int{1, 2})
extra := []int{3, 4}

merged1 := ints.Merge(extra)
collection.Dump(merged1.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
//   3 => 4 #int
// ]
```

Example: merging another collection

```go
// strings
strs := collection.New([]string{"a", "b"})
more := collection.New([]string{"c", "d"})

merged2 := strs.Merge(more)
collection.Dump(merged2.Items())
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
//   2 => "c" #string
//   3 => "d" #string
// ]
```

Example: merging struct slices

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

moreUsers := []User{
	{ID: 3, Name: "Carol"},
	{ID: 4, Name: "Dave"},
}

merged3 := users.Merge(moreUsers)
collection.Dump(merged3.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +ID   => 2 #int
//     +Name => "Bob" #string
//   }
//   2 => #main.User {
//     +ID   => 3 #int
//     +Name => "Carol" #string
//   }
//   3 => #main.User {
//     +ID   => 4 #int
//     +Name => "Dave" #string
//   }
// ]
```



<a name="Collection[T].Multiply"></a>
### Multiply


Multiply creates \`n\` copies of all items in the collection and returns a new collection.

Example:

```go
// integers
ints := collection.New([]int{1, 2})
out := ints.Multiply(3)
collection.Dump(out.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 1 #int
//   3 => 2 #int
//   4 => 1 #int
//   5 => 2 #int
// ]
```

Example:

```go
// strings
strs := collection.New([]string{"a", "b"})
out2 := strs.Multiply(2)
collection.Dump(out2.Items())
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
//   2 => "a" #string
//   3 => "b" #string
// ]
```

Example:

```go
// structs
type User struct {
	Name string
}

users := collection.New([]User{{Name: "Alice"}, {Name: "Bob"}})
out3 := users.Multiply(2)
collection.Dump(out3.Items())
// #[]main.User [
//   0 => #main.User {
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +Name => "Bob" #string
//   }
//   2 => #main.User {
//     +Name => "Alice" #string
//   }
//   3 => #main.User {
//     +Name => "Bob" #string
//   }
// ]
```

Example:

```go
// multiplying by zero or negative returns empty
none := ints.Multiply(0)
collection.Dump(none.Items())
// #[]int [
// ]
```



<a name="Collection[T].Pipe"></a>
### Pipe


Pipe passes the entire collection into the given function and returns the function's result.

This is useful for inline transformations, aggregations, or "exiting" a chain with a non\-collection value.

Example:

```go
// integers ‚Äì computing a sum
c := collection.New([]int{1, 2, 3})
sum := c.Pipe(func(col *collection.Collection[int]) any {
	total := 0
	for _, v := range col.Items() {
		total += v
	}
	return total
})
collection.Dump(sum)
// 6 #int
```

Example:

```go
// strings ‚Äì joining values
c2 := collection.New([]string{"a", "b", "c"})
joined := c2.Pipe(func(col *collection.Collection[string]) any {
	out := ""
	for _, v := range col.Items() {
		out += v
	}
	return out
})
collection.Dump(joined)
// "abc" #string
```

Example:

```go
// structs ‚Äì extracting just the names
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

names := users.Pipe(func(col *collection.Collection[User]) any {
	result := make([]string, 0, len(col.Items()))
	for _, u := range col.Items() {
		result = append(result, u.Name)
	}
	return result
})

collection.Dump(names)
// #[]string [
//   0 => "Alice" #string
//   1 => "Bob" #string
// ]
```



<a name="Collection[T].Pop"></a>
### Pop


Pop returns the last item and a new collection with that item removed. The original collection remains unchanged.

If the collection is empty, the zero value of T is returned along with an empty collection.

Example:

```go
// integers
c := collection.New([]int{1, 2, 3})
item, rest := c.Pop()
collection.Dump(item, rest.Items())
// 3 #int
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
// ]
```

Example:

```go
// strings
c2 := collection.New([]string{"a", "b", "c"})
item2, rest2 := c2.Pop()
collection.Dump(item2, rest2.Items())
// "c" #string
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
// ]
```

Example:

```go
// structs
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
})

item3, rest3 := users.Pop()
collection.Dump(item3, rest3.Items())
// #main.User {
//   +ID   => 2 #int
//   +Name => "Bob" #string
// }
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
// ]
```

Example:

```go
// empty collection
empty := collection.New([]int{})
item4, rest4 := empty.Pop()
collection.Dump(item4, rest4.Items())
// 0 #int
// #[]int [
// ]
```



<a name="Collection[T].PopN"></a>
### PopN


PopN removes and returns the last n items as a new collection, and returns a second collection containing the remaining items.

The popped items are returned in reverse order, matching the behavior of repeated Pop\(\) calls.

Example:

```go
// integers ‚Äì pop 2
c := collection.New([]int{1, 2, 3, 4})
popped, rest := c.PopN(2)
collection.Dump(popped.Items(), rest.Items())
// #[]int [
//   0 => 4 #int
//   1 => 3 #int
// ]
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
// ]
```

Example:

```go
// strings ‚Äì pop 1
c2 := collection.New([]string{"a", "b", "c"})
popped2, rest2 := c2.PopN(1)
collection.Dump(popped2.Items(), rest2.Items())
// #[]string [
//   0 => "c" #string
// ]
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
// ]
```

Example:

```go
// structs ‚Äì pop 2
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 1, Name: "Alice"},
	{ID: 2, Name: "Bob"},
	{ID: 3, Name: "Carol"},
})

popped3, rest3 := users.PopN(2)
collection.Dump(popped3.Items(), rest3.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 3 #int
//     +Name => "Carol" #string
//   }
//   1 => #main.User {
//     +ID   => 2 #int
//     +Name => "Bob" #string
//   }
// ]
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
// ]
```

Example:

```go
// n <= 0 ‚Üí returns empty popped + original collection
c3 := collection.New([]int{1, 2, 3})
popped4, rest4 := c3.PopN(0)
collection.Dump(popped4.Items(), rest4.Items())
// #[]int [
// ]
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
// ]
```

Example:

```go
// n exceeds length ‚Üí all items popped, rest empty
c4 := collection.New([]string{"x", "y"})
popped5, rest5 := c4.PopN(10)
collection.Dump(popped5.Items(), rest5.Items())
// #[]string [
//   0 => "y" #string
//   1 => "x" #string
// ]
// #[]string [
// ]
```



<a name="Collection[T].Prepend"></a>
### Prepend


Prepend returns a new collection with the given values added to the \*beginning\* of the collection.

The original collection is not modified.

Example:

```go
c := collection.New([]int{3, 4})
newC := c.Prepend(1, 2)
collection.Dump(newC.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 3 #int
//   3 => 4 #int
// ]
```

Example:

```go
// prepending strings
letters := collection.New([]string{"c", "d"})
out := letters.Prepend("a", "b")
collection.Dump(out.Items())
// #[]string [
//   0 => "a" #string
//   1 => "b" #string
//   2 => "c" #string
//   3 => "d" #string
// ]
```

Example:

```go
// prepending a struct
type User struct {
	ID   int
	Name string
}

users := collection.New([]User{
	{ID: 2, Name: "Bob"},
})

out2 := users.Prepend(User{ID: 1, Name: "Alice"})
collection.Dump(out2.Items())
// #[]main.User [
//   0 => #main.User {
//     +ID   => 1 #int
//     +Name => "Alice" #string
//   }
//   1 => #main.User {
//     +ID   => 2 #int
//     +Name => "Bob" #string
//   }
// ]
```

Example:

```go
// Prepending into an empty collection
empty := collection.New([]int{})
out3 := empty.Prepend(9, 8)
collection.Dump(out3.Items())
// #[]int [
//   0 => 9 #int
//   1 => 8 #int
// ]
```

Example:

```go
// Prepending no values ‚Üí returns a copy of original
c2 := collection.New([]int{1, 2})
out4 := c2.Prepend()
collection.Dump(out4.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
// ]
```



<a name="Collection[T].Push"></a>
### Push


Push returns a new collection with the given values appended.

Examples:

```go
// Simple type (ints)
nums := collection.New([]int{1, 2}).Push(3, 4)
// nums = [1, 2, 3, 4]

// Complex type (structs)
type User struct {
    Name string
    Age  int
}

users := collection.New([]User{
    {Name: "Alice", Age: 30},
    {Name: "Bob",   Age: 25},
}).Push(
    User{Name: "Carol", Age: 40},
    User{Name: "Dave",  Age: 20},
)

// users = [
//   {Alice 30},
//   {Bob 25},
//   {Carol 40},
//   {Dave 20},
// ]
```



<a name="Collection[T].Reduce"></a>
### Reduce


Reduce collapses the collection into a single accumulated value. The accumulator has the same type T as the collection's elements.

This is useful for computing sums, concatenations, aggregates, or any fold\-style reduction.

Example:

```go
// Sum integers
sum := collection.New([]int{1, 2, 3}).Reduce(0, func(acc, n int) int {
	return acc + n
})
collection.Dump(sum)
// 6 #int
```

Example:

```go
// Concatenate strings
joined := collection.New([]string{"a", "b", "c"}).Reduce("", func(acc, s string) string {
	return acc + s
})
collection.Dump(joined)
// "abc" #string
```

Example:

```go
// Aggregate struct fields
type Stats struct {
	Count int
	Sum   int
}

stats := collection.New([]Stats{
	{Count: 1, Sum: 10},
	{Count: 1, Sum: 20},
	{Count: 1, Sum: 30},
})

total := stats.Reduce(Stats{}, func(acc, s Stats) Stats {
	acc.Count += s.Count
	acc.Sum += s.Sum
	return acc
})

collection.Dump(total)
// #main.Stats [
//   +Count => 3 #int
//   +Sum   => 60 #int
// ]
```



<a name="Collection[T].Sort"></a>
### Sort


Sort returns a new collection sorted using the provided comparison function.

The comparison function \`less\(a, b\)\` should return true if \`a\` should come before \`b\` in the sorted order.

Sorting does NOT mutate the original collection‚ÄîSort always returns a new one.

Example:

```go
// integers
c := collection.New([]int{5, 1, 4, 2})
sorted := c.Sort(func(a, b int) bool { return a < b })
collection.Dump(sorted.Items())
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
//   2 => 4 #int
//   3 => 5 #int
// ]
```

Example:

```go
// strings (descending)
c2 := collection.New([]string{"apple", "banana", "cherry"})
sorted2 := c2.Sort(func(a, b string) bool { return a > b })
collection.Dump(sorted2.Items())
// #[]string [
//   0 => "cherry" #string
//   1 => "banana" #string
//   2 => "apple" #string
// ]
```

Example:

```go
// structs
type User struct {
	Name string
	Age  int
}

users := collection.New([]User{
	{Name: "Alice", Age: 30},
	{Name: "Bob", Age: 25},
	{Name: "Carol", Age: 40},
})

// Sort by age ascending
sortedUsers := users.Sort(func(a, b User) bool {
	return a.Age < b.Age
})
collection.Dump(sortedUsers.Items())
// #[]main.User [
//   0 => #main.User {
//     +Name => "Bob" #string
//     +Age  => 25 #int
//   }
//   1 => #main.User {
//     +Name => "Alice" #string
//     +Age  => 30 #int
//   }
//   2 => #main.User {
//     +Name => "Carol" #string
//     +Age  => 40 #int
//   }
// ]
```



<a name="Collection[T].Take"></a>
### Take


Take returns a new collection containing the first \`n\` items when n \> 0, or the last \`|n|\` items when n \< 0. If n exceeds the collection length, the entire slice \(or nothing\) is returned.

Mirrors Laravel's take\(\) semantics.

Examples:

```go
New([]int{0,1,2,3,4,5}).Take(3)  ‚Üí [0,1,2]
New([]int{0,1,2,3,4,5}).Take(-2) ‚Üí [4,5]
```



<a name="Collection[T].TakeUntilFn"></a>
### TakeUntilFn


TakeUntilFn returns items until the predicate function returns true. The matching item is NOT included. Example:

```go
c := collection.New([]int{1, 2, 3, 4})
out := c.TakeUntilFn(func(v int) bool { return v >= 3 }) // [1, 2]
```

// result is \[1, 2\]



<a name="Collection[T].Tap"></a>
### Tap


Tap invokes fn with the collection pointer for side effects \(logging, debugging, inspection\) and returns the same collection to allow chaining.

Tap does NOT modify the collection itself; it simply exposes the current state during a fluent chain.

Example:

```go
captured := []int{}
c := New([]int{3,1,2}).
    Sort(func(a,b int) bool { return a < b }).  // ‚Üí [1,2,3]
    Tap(func(col *Collection[int]) {
        captured = append([]int(nil), col.items...) // snapshot
    }).
    Filter(func(v int) bool { return v >= 2 })     // ‚Üí [2,3]
```

After Tap, 'captured' contains the sorted state: \[\]int\{1,2,3\} and the chain continues unaffected.



<a name="Collection[T].ToJSON"></a>
### ToJSON


ToJSON converts the collection's items into a compact JSON string.

If marshalling succeeds, a JSON\-encoded string and a nil error are returned. If marshalling fails, the method unwraps any json.Marshal wrapping so that user\-defined MarshalJSON errors surface directly.

This method never panics.

Example:

```go
c := collection.New([]int{1, 2, 3})
out, err := c.ToJSON()
// out: "[1,2,3]"
// err: nil
```

Example \(error\):

```go
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the JSON\-encoded representation of the collection
- error : nil on success, or the unwrapped marshalling error



<a name="Collection[T].ToPrettyJSON"></a>
### ToPrettyJSON


ToPrettyJSON converts the collection's items into an indented, human\-readable JSON string.

If marshalling succeeds, a formatted JSON string and nil error are returned. If marshalling fails, the underlying error is unwrapped so that user\-defined MarshalJSON failures surface directly \(e.g., "marshal failure"\) rather than the json.MarshalIndent wrapper.

This method never panics.

Example:

```go
c := collection.New([]string{"a", "b"})
out, err := c.ToPrettyJSON()
// out:
// [
//   "a",
//   "b"
// ]
// err: nil
```

Example \(error\):

```go
type Bad struct{}
func (Bad) MarshalJSON() ([]byte, error) {
    return nil, fmt.Errorf("marshal failure")
}

c := collection.New([]Bad{{}})
out, err := c.ToPrettyJSON()
// out: ""
// err.Error(): "marshal failure"
```

Returns:

- string: the pretty\-printed JSON representation
- error : nil on success, or the unwrapped marshalling error



<a name="Collection[T].Transform"></a>
### Transform


Transform applies fn to every item \*in place\* and replaces the values with the returned values. This matches Laravel's transform\(\), which mutates the collection instead of returning a new one. Example:

```go
c := collection.New([]int{1,2,3})
c.Transform(func(v int) int { return v * 2 })
// c is now [2,4,6]
```



<a name="Collection[T].Unique"></a>
### Unique


Unique returns a collection with duplicate items \(according to eq\) removed, preserving the first occurrence of each unique value.

eq should return true if the two values are considered equal. Example usage:

```go
c := collection.New([]int{1, 2, 2, 3, 4, 4, 5})
unique := c.Unique(func(a, b int) bool { return a == b })

// result: [1, 2, 3, 4, 5]
```

















<a name="NewNumeric"></a>
### NewNumeric


NewNumeric wraps a slice of numeric types in a NumericCollection. A shallow copy is made so that further operations don't mutate the original slice.





<a name="NumericCollection[T].Avg"></a>
### Avg


Avg returns the average of the collection values as a float64. If the collection is empty, Avg returns 0.

Example: int

```go
// int
c := collection.NewNumeric([]int{2, 4, 6})
collection.Dump(c.Avg())
// 4.000000 #float64
```

Example: float

```go
// float64
c2 := collection.NewNumeric([]float64{1.5, 2.5, 3.0})
collection.Dump(c2.Avg())
// 2.333333 #float64
```



<a name="NumericCollection[T].Max"></a>
### Max


Max returns the largest numeric item in the collection. The second return value is false if the collection is empty.

Example:

```go
// integers
c := collection.NewNumeric([]int{3, 1, 2})

max1, ok1 := c.Max()
collection.Dump(max1, ok1)
// 3    #int
// true #bool
```

Example:

```go
// floats
c2 := collection.NewNumeric([]float64{1.5, 9.2, 4.4})

max2, ok2 := c2.Max()
collection.Dump(max2, ok2)
// 9.200000 #float64
// true     #bool
```

Example:

```go
// empty numeric collection
c3 := collection.NewNumeric([]int{})

max3, ok3 := c3.Max()
collection.Dump(max3, ok3)
// 0     #int
// false #bool
```



<a name="NumericCollection[T].Median"></a>
### Median


Median returns the statistical median of the numeric collection as float64. Returns \(0, false\) if the collection is empty.

Odd count ‚Üí middle value Even count ‚Üí average of the two middle values

Example:

```go
// odd number of items
c := collection.NewNumeric([]int{3, 1, 2})

median1, ok1 := c.Median()
collection.Dump(median1, ok1)
// 2.000000 #float64
// true     #bool
```

Example:

```go
// even number of items
c2 := collection.NewNumeric([]int{10, 2, 4, 6})

median2, ok2 := c2.Median()
collection.Dump(median2, ok2)
// 5.000000 #float64
// true     #bool
```

Example:

```go
// floating-point values
c3 := collection.NewNumeric([]float64{1.1, 9.9, 3.3})

median3, ok3 := c3.Median()
collection.Dump(median3, ok3)
// 3.300000 #float64
// true     #bool
```

Example:

```go
// empty numeric collection
c4 := collection.NewNumeric([]int{})

median4, ok4 := c4.Median()
collection.Dump(median4, ok4)
// 0.000000 #float64
// false    #bool
```



<a name="NumericCollection[T].Min"></a>
### Min


Min returns the smallest numeric item in the collection. The second return value is false if the collection is empty.

Example:

```go
// integers
c := collection.NewNumeric([]int{3, 1, 2})
min, ok := c.Min()
collection.Dump(min, ok)
// 1 #int
// true #bool
```

Example:

```go
// floats
c2 := collection.NewNumeric([]float64{2.5, 9.1, 1.2})
min2, ok2 := c2.Min()
collection.Dump(min2, ok2)
// 1.200000 #float64
// true #bool
```

Example:

```go
// empty collection
empty := collection.NewNumeric([]int{})
min3, ok3 := empty.Min()
collection.Dump(min3, ok3)
// 0 #int
// false #bool
```



<a name="NumericCollection[T].Mode"></a>
### Mode


Mode returns the most frequent numeric value\(s\) in the collection. If multiple values tie for highest frequency, all are returned in first\-seen order.

Example:

```go
// integers ‚Äì single mode
c := collection.NewNumeric([]int{1, 2, 2, 3})
mode := c.Mode()
collection.Dump(mode)
// #[]int [
//   0 => 2 #int
// ]
```

Example:

```go
// integers ‚Äì tie for mode
c2 := collection.NewNumeric([]int{1, 2, 1, 2})
mode2 := c2.Mode()
collection.Dump(mode2)
// #[]int [
//   0 => 1 #int
//   1 => 2 #int
// ]
```

Example:

```go
// floats
c3 := collection.NewNumeric([]float64{1.1, 2.2, 1.1, 3.3})
mode3 := c3.Mode()
collection.Dump(mode3)
// #[]float64 [
//   0 => 1.100000 #float64
// ]
```

Example:

```go
// empty collection
empty := collection.NewNumeric([]int{})
mode4 := empty.Mode()
collection.Dump(mode4)
// <nil>
```



<a name="NumericCollection[T].Sum"></a>
### Sum


Sum returns the sum of all numeric items in the NumericCollection. If the collection is empty, Sum returns the zero value of T.

Example:

```go
// integers
c := collection.NewNumeric([]int{1, 2, 3})
total := c.Sum()
collection.Dump(total)
// 6 #int
```

Example:

```go
// floats
c2 := collection.NewNumeric([]float64{1.5, 2.5})
total2 := c2.Sum()
collection.Dump(total2)
// 4.000000 #float64
```

Example:

```go
// empty collection
c3 := collection.NewNumeric([]int{})
total3 := c3.Sum()
collection.Dump(total3)
// 0 #int
```




Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->